---
aliases:
  - Используйте std::unique_ptr для управления ресурсами путем исключительного владения
---
Когда вы обращаетесь к интеллектуальным указателям, обычно ближе других под рукой должен находиться `std::unique_ptr`. Разумно предположить, что по умолчанию `std::unique_ptr` имеет тот же размер, что и обычный указатель, и для большинства операций (включая разыменования) выполняются точно такие же команды. Это означает, что такие указатели можно использовать даже в ситуациях, когда важны расход памяти и процессорного времени. Если встроенные указатели для вас достаточно малы и быстры, то почти наверняка такими же будут для вас и указатели `std::unique_ptr`.

Интеллектуальные указатели `std::unique_ptr` воплощают в себе семантику *исключительного владения*. Ненулевой `std::unique_ptr` всегда владеет тем, на что указывает. Перемещение `std::unique_ptr` передает владение от исходного указателя целевому. (Исходный указатель при этом становится нулевым)

Копирование `std::unique_ptr` не разрешается, так как если вы можете копировать `std::unique_ptr`, то у вас будут два `std::unique_ptr`, указывающих на один и тот же ресурс, и каждый из них будет считать, что именно он владеет этим ресурсом (а значит, должен его уничтожить). 

Таким образом, `std::unique_ptr` является *только перемещаемым типом*. При деструкции ненулевой `std::unique_ptr` освобождает ресурс, которым владеет. По умолчанию освобождение ресурса выполняется с помощью оператора `delete`, примененного ко встроенному указателю в `std::unique_ptr`.

Обычное применение `std::unique_ptr` - возвращаемый тип фабричных функций для объектов иерархии. Предположим, что у нас имеется иерархия типов инвестиций (например, акции, облигации, недвижимость и т.п) с базовым классом `Investment`.
```cpp
class Investment { ... };

class Stock: public Investment { ... };
class Bond: public Investment { ... };
class RealEstate: public Investment { ... };

```
Фабричная функция для такой иерархии обычно выделяет объект в динамической памяти и возвращает указатель на него, так что за удаление объекта по завершении работы с ним отвечает вызывающая функция. Это в точности соответствует интеллектуальному указателю `std::unique_ptr`, поскольку вызывающий код получает ответственность за ресурс, возвращенный фабрикой (т.е. исключительное владение ресурсом), и `std::unique_ptr` автоматически удаляет то, на что указывает, при уничтожении указателя `std::unique_ptr`. Фабричная функция для иерархии `Investment` может быть объявлена следующим образом:
```cpp
template<typename... Ts>         // Возвращает std::unique_ptr
std::unique_ptr<Investment>      // на объект, созданый из
makeInvestment(Ts&&... params);  // данных аргументов
```
Вызывающий код может использовать возвращаемый `std::unique_ptr` как в одной области видимости,
```cpp
{
	...
	// pInvestment имеет тип `std::unique_ptr`
	auto pInvestment = makeInvestment(arguments);
} // уничтожение *pInvestment
```
так и в сценарии передачи владения, таком, как когда `std::unique_ptr`, возвращенный фабрикой, перемещается в контейнер, элемент контейнера впоследствии перемещается в член-данные объекта, а этот объект позже уничтожается. Когда это происходит, член данные `std::unique_ptr` объекта также уничтожается, что приводит к освобождению ресурса, полученного от фабрики. Если цепочка владения прерывается из-за исключения или иного нетипичного потока управления (например, раннего возврата из функции или из-за `break` в цикле), для `std::unique_ptr`, владеющего ресурсом, в конечном итоге вызывается деструктор, и тем самым освобождается захваченный ресурс.

По умолчанию это освобождение выполняется оператором `delete`, но в процессе конструирования объект `std::unique_ptr` можно настроить для использования *пользовательских удалителей* (custom deleters): произвольных функций (или функциональных объектов, включая получающиеся из лямбда выражений), вызываемых для освобождения ресурсов. Если объект, созданный с помощью `makeInvestment`, не должен быть удален непосредственно с помощью `delete`, а сначала должна быть внесена запись в журнал, `makeInvestment` можно реализовать следующим образом:
```cpp
auto delInvmt = [](Investment* pInvestment) {
	makeLogEntry(pInvestment);
	delete pInvestment;
};
template<typename... Ts>
sts::unique_ptr<Investment, decltype(delInvmt)>
makeInvestment(Ts&&... params)
{
	std::unique_ptr<Investment, decltype(delInvmt)> pInv(nullptr, delInvmt);
	if (/* Должен быть создан объект Stock */) {
		pInv.reset(new Stock(std::forward<Ts>(params)...));
	} else if (/* Должен быть создан объект Bond */) {
		pInv.reset(new Bond(std::forward<Ts>(params)...));
	} else if (/* Должен быть создан объект RealEstate */) {
		pInv.reset(new RealEstate(std::forward<Ts>(params)...));
	}
	return pInv;
}
```