Давайте порадуемся объявлению локальной переменной, инициализированной разыменованием итератора:
```cpp
template<typename It>
void dwim(It b, It e)
{
	while (b != e) {
		typename std::iterator_traits<It>::value_type
		    currValue = *b;
	}
}
```
Жуть. `typename std::iterator_traits<It>::value_type` - просто чтобы записать тип значения, на которое указывает итератор?
С таким же успехом можно попробовать объявить локальную переменную,  тип которой такой же, как у лямбда-выражения. Но его тип известен только компилятору!
Никакого удовольствия от программирования на С++!

В С++11 все эти проблемы решены с помощью ключевого слова `auto`. Тип переменных, объявленных как `auto`, выводится из инициализатора, так что они обязаны быть инициализированными. Это значит - прощай проблема неинициализированных переменных:
```cpp
int x1;       // Потенциально неинициализированная переменная
auto x2;      // Ошибка! Требуется инициализатор
auto x3 = 0;  // Все отлично, переменная x корректно определена
```
Нет проблем с объявлением локальной переменной, значением которой является разыменование итератора:
```cpp
template<typename It>
void dwim(It b, It e)
{
	while (b != e) {
		auto currValue = *b;
	}
}
```
А поскольку `auto` использует вывод типов (см. раздел [[Вывод типа auto]]), он может представлять типы, известные только компиляторам:
```cpp
auto derefUPLess =                    // Функция сравнения
[](const std::unique_ptr<Widget>& p1, // для значений, на
   const std::unique_ptr<Widget>& p2) // которые указывают
   { return *p1 < *p2; };             // std::unique_ptr
```
Несмотря на всю крутость вы, вероятно, думаете, что можно обойтись и без `auto` для объявления переменной, которая хранит лямбда-выражение, поскольку мы можем использовать объект `std::function`. Это так, можем, но, возможно, это не то, что вы на самом деле подразумеваете. Давайте разбираться.

`std::function` - шаблон стандартной библиотеки C++11, который обобщает идею указателя на функцию. В то время как указатели на функции могут указывать только на функции, объект `std::function` может ссылаться на любой вызываемый объект, т.е. на все, что может быть вызвано как функция.
Так же как при создании указателя на функцию вы должны указать тип функции, на которую указываете (т.е. сигнатуру функции, на которую хотите указать), вы должны указать тип функции, на которую будет ссылаться создаваемый объект `std::function`.
Это делается с помощью параметра шаблона `std::function`. Например, для объявления объекта `std::function` с именем `func`, который может ссылаться на любой вызываемый объект, действующий так, как если бы его сигнатура была
```cpp
bool(const std::unique_ptr<Widget>&,  // Сигнатура С++11 для
	 const std::unique_ptr<Widget>&); // функции сравнения
									  // std::unique_ptr<Widget>
```
следует написать следующее:
```cpp
std::function<bool(const std::unique_ptr<Widget>&,
				   const std::unique_ptr<Widget>&)> func;
```
Поскольку лямбда-выражения дают вызываемые объекты, замыкания могут храниться в объектах `std::function`. Это означает, что можно объявить С++11-версию `derefUPLess` без применения `auto` следующим образом:
```cpp
std::function<bool(const std::unique_ptr<Widget>&,
				   const std::unique_ptr<Widget>&)>
	derefUPLess = [](const std::unique_ptr<Widget>& p1,
				     const std::unique_ptr<Widget>& p2)
		{ return *p1 < *p2; };
```
Важно понимать, что, даже если оставить в стороне синтаксическую многословность и необходимость повторения типов параметров, использования `std::function` - не то же самое, что использования `auto`. Переменная, объявленная с использованием `auto` и хранящая замыкание, имеет тот же тип, что и замыкание, и как таковая использует только то количество памяти, которое требуется замыканию. Тип переменной, объявленной как `std::function` и хранящей замыкание, представляет собой конкретизацию шаблона `std::function`, которая имеет фиксированный размер для каждой заданной сигнатуры. Этот размер может быть не адекватным для замыкания, которое требуется хранить, и в этом случае конструктор `std::function` будет выделять для хранения замыкания динамическую память.

В результате объект `std::function` использует больше памяти, чем объект, объявленный с помощью `auto`. Кроме того, из-за деталей реализации это ограничивает возможности встраивания и приводит к косвенным вызовам функции, так что вызовы замыкания через объект `std::function` обычно выполняются медленнее, чем вызовы посредством объекта, объявленного как `auto`. 

Другими словами, подход с использованием `std::function` в общем случае более громоздкий, требующий больше памяти и более медленный, чем подход с помощью `auto`, и к тому же может приводить к генерации исключений, связанных с нехваткой памяти. Ну и, написать "auto" гораздо проще, чем указывать тип для инстанцирования `std::function`. В соревнованиях между `auto` и `std::function` для хранения замыкания побеждает `auto`. (Подобные аргументы можно привести и в пользу предпочтения `auto` перед `std::function` для хранения результатов вызовов `std::bind`, но все равно в разделе [[Предпочитайте лямбда-выражения применению stdbind]] я делаю все, чтобы убедить вас использовать вместо `std::bind` лямбда-выражения...).

Преимущества `auto` выходят за рамки избегания неинициализированных переменных, длинных объявлений переменных и возможности непосредственного хранения замыкания. Кроме того, имеется возможность избежать того, что я называю проблемой "сокращения типа" (type shortcuts). Вот кое-что, что вы, вероятно, уже видели, а возможно, даже писали:
```cpp
std::vector<int> v;
...
unsigned sz = v.size();
```
Официальный возвращаемый тип `v.size()` - `std::vector<int>::size_type`, но об этом знает не так уж много разработчиков. `std::vector<int>::size_type` определен как беззнаковый целочисленный тип, так что огромное количество программистов считают, что `unsigned` вполне достаточно, и пишут исходные тексты, подобные показанному выше.
Это может иметь некоторые последствия. В 32-разрядной Windows, например, и `unsigned`, и `std::vector<int>::size_type` имеют один и тот же размер, но в 64-разрядной Windows `unsigned` содержит 32 бита, а `std::vector<int>::size_type`- 64 бита.
Это означает, что код, который работал в 32-разрядной Windows, может вести себя некорректно в 64-разрядной Windows. И кому хочется тратить время на подобные вопросы при переносе приложения с 32-разрадной операционной системы на 64-разрядную?
Применение `auto` гарантирует, что вам не придется этим заниматься:
```cpp
auto sz = v.size(); // Тип sz - std::vector<int>::size_type
```
Вы еще не уверены в разумности применения `auto`? Тогда рассмотрите следующий код.
```cpp
std::unordered_map<std::string, int> m;
...
for (const std::pair<std::string, int>& p : m)
{
	... // Что-то делаем с p
}
```
Выглядит вполне разумно... но есть одна проблема.
Чтобы разобраться, что здесь не так, надо вспомнить, что часть `std::unordered_map`, содержащая ключ, является константой, так что тип `std::pair` в хеш-таблице вовсе не `std::pair<std::string, int>`, а `std::pair<const std::string, int>`. Но переменная `p` в приведенном выше цикле объявлена иначе. В результате компилятор будет искать способ преобразовать объекты `std::pair<const std::string, int>` (хранящиеся в хеш-таблице) в объекты `std::pair<std::string, int>` (объявленный тип `p`). Этот способ - создание временного объекта типа, требуемого `p`, чтобы скопировать в него каждый объект из `m` с последующим связыванием ссылки `p` с этим временным объектом. В конце каждой итерации цикла временный объект уничтожается. Если этот цикл написан вами, вы, вероятно, будете удивлены его поведением, поскольку почти наверняка планировали просто связывать ссылку `p` с каждым элементом в `m`.
Такое непреднамеренное несоответствие легко лечится с помощью `auto`:
```cpp
for (const auto& p : m)
{
	... // Как и ранее
}
```
Это не просто более эффективно - это еще и менее многословно. Кроме того, этот код имеет очень привлекательную особенность - если вы возьмете адрес `p`, то можете быть уверены, что получите указатель на элемент в `m`. В коде, не использующем `auto`, вы получите указатель на временный объект - объект, который будет уничтожен в конце итерации цикла.

Два последний примера - запись `unsigned` там, где вы должны были написать `std::vector<int>::size_type`, и запись `std::pair<std::string, int>` там, где вы должны были написать `std::pair<const std::string, int>`, - демонстрируют, как явное указание типов может привести к неявному их преобразованию, которое вы не хотели и не ждали. Если вы используете в качестве типа целевой переменной `auto`, вам не надо беспокоиться о несоответствиях между типом объявленной переменной и типом инициализирующего ее выражения.

Таким образом, имеется несколько причин для предпочтительного применения `auto` по сравнению с явным объявлением типа. Но `auto` не является совершенным. Тип для каждой переменной, объявленной как `auto`, выводится из инициализирующего ее выражения, а некоторые инициализирующие выражения имеют типы, которые не предполагались и нежелательны. Условия, при которых возникают такие ситуации, и что при этом можно сделать, рассматриваются в разделах [[Вывод типа auto]]и [[Если auto выводит нежелательный тип, используйте явно типизированный инициализатор]], поэтому здесь я не буду их рассматривать. Вместо этого я уделю внимание другому вопросу, который может вас волновать при использовании `auto` вместо традиционного объявления типа, - удобочитаемость полученного исходного текста.

Для начала сделайте глубокий вдох и расслабьтесь. Применение `auto` - возможность, а не требование. Если, в соответствии с вашими профессиональными представлениями, ваш код будет понятнее или легче сопровождаемым или лучше в каком-то ином отношении при использовании явным объявлений типов, вы можете продолжать их использовать. Но имейте в виду, что С++ - не первый язык, принявший на вооружение то, что в мире языков программирования известно как *вывод типов* (type inference). Другие процедурные статически типизированные языки программирования (например, С#, D, Scala, Visual Basic) обладают более или менее эквивалентными возможностями, не говоря уже о множестве статически типизированных функциональных языков (например, ML, Haskell, OCaml, F# и др.). В частности, это объясняется успехом динамически типизированных языков программирования, таких как Perl, Python, Ruby, в которых явная типизация переменных - большая редкость. Сообщество разработчиков программного обеспечения имеет обширный опыт работы с выводом типов, и он продемонстрировал, что в такой технологии нет ничего мешающего созданию и поддержке крупных приложений промышленного уровня.

Некоторых разработчиков беспокоит тот факт, что применение `auto` исключает возможность определения типа при беглом взгляде на исходный текст. Однако возможности IDE показывать типы объектов часто устраняют эту проблему (даже если принять во внимание обсуждавшиеся в разделе [[Как просмотреть выведенные типы]] вопросы, связанные с выводом типов в IDE), а во многих случаях абстрактный взгляд на тип объекта столь же полезен, как и точный тип.
Зачастую достаточно, например, знать, что объект является контейнером, счетчиком или интеллектуальным указателем, не зная при этом точно, каким именно контейнером, счетчиком или указателем. При правильном подборе имен переменных такая абстрактная информация о типе почти всегда оказывается под рукой.

Суть дела заключается в том, что явно указываемые типы зачастую мало что дают, кроме того что открывают возможности для ошибок - в плане как корректности, так и производительности программ. Кроме того, типы `auto` автоматически изменяются при изменении типов инициализирующих их выражений, а это означает облегчение выполнения рефакторинга при использовании `auto`. Например, если функция объявлена как возвращающая `int`, но вы позже решите, что `long` вас больше устраивает, вызывающий код автоматически обновится при следующей компиляции (если результат вызова функции хранится в переменной, объявленной как `auto`). Если результат хранится в переменной, объявленной как `int`, вы должны найти все точки вызова функции и внести необходимые изменения.

>[!note] Следует запомнить
>- Переменные, объявленные как `auto`, должны быть инициализированы; в общем случае они невосприимчивы к несоответствиям типов, которые могут привести к проблемам переносимости или эффективности; могут облегчить процесс рефакторинга; и обычно требуют куда меньшего количества ударов по клавишам, чем переменные с явно указанными типами.
>- Переменные, объявленные как `auto`, могут быть подвержены неприятностями, описанным в разделах [[Вывод типа auto]] и [[Если auto выводит нежелательный тип, используйте явно типизированный инициализатор]].