В разделе [[Предпочитайте auto явному объявлению типа]] поясняется, что применение `auto` для объявления переменных предоставляет ряд технических преимуществ по сравнению с явным указанием типов, но иногда вывод `auto` идет налево там, где вы хотите направо. Предположим, например, что у меня есть функция, которая получает `Widget` и возвращает `std::vector<bool>`, где каждый `bool` указывает , обладает ли `Widget` определенным свойством:
```cpp
std::vector<bool> features(const Widget& w);
```
Предположим далее, что пятый бит указывает наличие высокого приоритета у `Widget`. Мы можем написать следующий код:
```cpp
Widget w;
...
bool highPriority = features(w)[5]; // Имеет ли w высокий приоритет?
...
processWidget(w, highPriority);     // Обработка w в соответствии с
                                    // приоритетом
```
В этом коде нет ничего неверного, он корректно работает. Но если мы внесем кажущееся безобидным изменение и заменим явный тип `highPriority` типом `auto`
```cpp
auto highPriority = features(w)[5]; // Имеет ли w высокий приоритет?
```
то ситуация изменится. Код будет продолжать компилироваться, но его поведение больше не будет предсказуемым:
```cpp
processWidget(w, highPriority);     // Неопределенное поведение
```
В коде, использующем `auto`, тип `highPriority` больше не является `bool`. Хотя концептуально `std::vector<bool>` хранит значения `bool`, `operator[]` у `std::vector<bool>` не возвращает ссылку на элемент контейнера (то, что `std::vector::operator[]` возвращает для всех типов *за исключением `bool`*). Вместо этого возвращается объект типа `std::vector<bool>::reference` (класса, вложенного в `std::vector<bool>`).

Тип `std::vector<bool>::reference` существует потому, что `std::vector<bool>` определен как хранящий значения `bool` в упакованном виде, по одному биту на каждое значение. Это создает проблему для оператора `operator[]` класса `std::vector<bool>`, поскольку `operator[]` класса `std::vector<T>` должен возвращать `T&`, но С++ запрещает ссылаться на отдельные биты. Будучи не в состоянии вернуть `bool&`, оператор `operator[]` класса `std::vector<bool>` возвращает объект, который *действует подобно `bool&`*.

Для успешной работы объекты `std::vector<bool>::reference` должны быть применимы по сути во всех контекстах, где применим `bool&`. Среди прочих возможностей `std::vector<bool>::reference` обладает неявным преобразованием в `bool`. (Не в `bool&`, а именно в `bool`. Пояснение всего ряда методов, используемых `std::vector<bool>::reference` для эмуляции поведения `bool&` завело бы нас слишком далеко, так что я просто замечу, что это неявное преобразование является только одним из камней в существенно большей мозаике.)

С учетом этой информации посмотрим еще раз на следующую часть исходного кода:
```cpp
bool highPriority = features(w)[5]; // Явное объвление типа
```
Здесь `features` возвращает объект `std::vector<bool>`, для которого вызвается `operator[]`. Этот оператор возвращает объект `std::vector<bool>::reference`, который затем неявно преобразуется в значение типа `bool`, необходимое для инициализации `highPriority`. Таким образом, `highPriority` в конечном итоге получает значение пятого бита из `std::vector<bool>`, возвращенного функцией `features`, так, как и предполагалось.

Но что же произойдет, если переменная `highPriority` будет объявлена как `auto`?
```cpp
auto highPriority = features(w)[5]; // Имеет ли w высокий приоритет?
```
Функция `features`, как и ранее, возвращает объект типа `std::vector<bool>`, и, как и ранее, выполняется его `operator[]`. Оператор возвращает объект типа `std::vector<bool>::reference`, но дальше привычный ход событий изменяется, так как `auto` приводит к выводу типа переменной `hightPriority`. Теперь переменная `hightPriority` не получает значение пятого бита `std::vector<bool>`, возвращенного вызовом `features`.

Полученное ею значение зависит от того, как реализован тип `std::vector<bool>::reference`. Одна из реализаций таких объектов состоит в том, чтобы содержать указатель на машинное слово с интересующим нас битом и смещение этого бита в слове. Рассмотрим, что это означает для инициализации `highPriority`, в предположении, что имеет место именно такая реализация `std::vector<bool>::reference`.

Вызов `features` возвращает временный объект `std::vector<bool>`. Этот объект не имеет имени, но для упрощения нашего рассмотрения я буду называть его `temp`. Для `temp` вызывается `operator[]`, в результате чего возвращается объект `std::vector<bool>::reference`, содержащий указатель на слово в структуре данных, хранящей интересующий нас бит (эта структура находится под управлением `temp`), плюс смещение в слове, соответствующее пятому биту. Переменная `highPriority` представляет собой копию этого объекта `std::vector<bool>::reference`, так что `highPriority` тоже содержит указатель на слово в `temp` плюс смещение, соответствующее пятому биту. В конце инструкции объект `temp` уничтожается, так как это объект временный. В результате переменная `highPriority` содержит висячий указатель, что и дает неопределеное поведение при вызове `processWidget`. 

Класс `std::vector<bool>::reference` является примером *прокси-класса*, т.е. класса, цель которого - эмуляция и дополнение поведения некоторого другого типа. Прокси-классы применяются для множества разных целей. Например, `std::vector<bool>::reference` нужен для того, чтобы создать иллюзию, что `operator[]` класса `std::vector<bool>` возвращает ссылку на бит, а интеллектуальные указатели стандартной библиотеки являются прокси-классами, которые добавляют к обычным указателям управление ресурсами. Полезность прокси-классов - давно установленный и не вызывающий сомнений факт. Фактически шаблон проектирование "Прокси" - один из наиболее давних членов пантеона шабонов проектирования программного обеспечения.

Одни прокси-классы спроектированы так, чтобы быть очевидными для клиентов. Это, например, классы `std::shared_ptr` и `std::unique_ptr`. Другие прокси-классы спроектированы для более-менее невидимой работы. Примером такого "невидимого" прокси-класса является `std::vecotr<bool>::reference`, как и его собрат `std::bitset::reference` из класса `std::bitset`.

В этом же лагере находятся некоторые классы библиотек С++, применяющих технологию, известную как *шаблоны выражений* (expression templates). Такие библиотеки изначально разрабатывались для повышения эффективности кода для числовых вычислений. Например, для заданного класса `Matrix` и объектов `m1`, `m2`, `m3` и `m4` класса `Matrix`, выражение
```cpp
Matrix sum = m1 + m2 + m3 + m4;
```
может быть вычислено более эффективно, если `operator+` для объектов `Matrix` возвращает не сам результат, а его прокси-класс. Иначе говоря, `operator+` для двух объектов `Matrix` должен возвращать объект прокси-класса, такого как `Sum<Matrix, Matrix>`, а не объект `Matrix`.
Как и в случае с `std::vector<bool>::reference` и `bool`, должно иметься неявное преобразование из прокси-класса в `Matrix`, которое позволит инициализировать `sum` прокси-объектом, полученным из выражения справа от знака "=". (Тип этого объекта будет традиционно кодировать все выражение инициализации, т.е. быть чем-то наподобие `Sum<Sum<Sum<Matrix, Matrix>, Matrix, Matrix>`. Определенно, это тип, от которого следует защитить клиентов.)

В качестве общего правила "невидимые" прокси-классы не умеют хорошо работать вместе с `auto`. Для объектов таких классов зачастую не предусматривается существование более длительное, чем одна инструкция, так что создание переменных таких типов, как правило, нарушает фундаментальные предположения библиотеки. Следоыательно, надо избегать кода следующего вида:
`auto someVar = <выражение с типов "невидимого" прокси-класса;`

Но как распознать, когда используется прокси-объект? Программное обеспечение, использующее невидимый прокси, вряд ли станет его рекламировать. Ведь эти прокси-объекты должны быть невидимыми, по крайней мере концептуально! И если вы обнаружите их, то действительно ли следует отказываться от `auto` и массы преимуществ для него?

Давайте сначала зададимся вопросом, как найти прокси. Хотя "невидимые" прокси-классы спроектированы таким образом, чтобы при повседневном применении "летать вне досягаемости радара программиста", использующие их библиотеки часто документируют такое применение. Чем лучше вы знакомы с основными проектными решениями используемых вами библиотек, тем менее вероятно, что вы пропустите такой прокси незамеченным.

Там, где документация слишком краткая, на помощь могут прийти заголовочные файлы. Возможность сокрытия прокси-объектов в исходном коде достаточно редка. Обычно прокси-объекты возвращаются из функций, которые вызываются клиентами, так что сигнатуры этих функций отражают существование прокси-объектов. Например, так выглядит `std::vector<bool>::operator[]`:
```cpp
namespace std {
	template <class Allocator>
	class vector<bool, Allocator> {
	public:
		...
		class reference { ... };

		reference operator[](size_type n);
	}
}
```
В предположении, что вы знаете, что `operator[]` у `std::vector<T>` обычно возвращает `T&`, необычные возвращаемый тип у `operator[]` в данном случае должен навести вас на мысль о применении здесь прокси-класса. Уделяя повышенное внимание используемым интерфейсам, часто можно выявить наличие прокси-классов.

На практике многие разработчики обнаруживают применение прокси-классов только тогда, когда пытаются отследить источник тпинственных проблем при компиляции или отладить никак не проходящий тесты модуль. Независимо от того, как вы его обнаржили, после того как выясняется, что `auto` определен как выведенный тип прокси-класса вместо "проксифицирующего" типа, решение не требует отказа от `auto`. Само по себе ключевое слово `auto` проблемой не является. Проблема в том, что `auto` выводит не тот тип, который вам нужен. Решение заключается в том, чтобы обеспечить вывод другого типа. Способ достижения этого заключается в том, что я называю *идиомой явной типизации инициализтора*.

Идиома явной типизации инициализатора включает объявление переменной с использованием `auto`. Например, вот как можно использовать эту идиому, чтобы заставить `highPriority` стать переменной типа `bool`:
```cpp
auto highPriority = static_cast<bool>(features(w)[5]);
```
Здесь `features(w)[5]` продолжает, как и ранее, возвращать объект типа `std::vector<boo>::reference`, но приведение изменяет тип выражения на `bool`, который `auto` затем выводит в качестве типа переменной `highPriority`. Во время выполнения программы объект `std::vector<bool>::reference`, который возвращается вызовом `std::vector<bool>::operator[]`, преобразуется в значение `bool` и в качестве части преобразования выполняется разыменование все еще корректного указателя на `std::vector<bool>`, возвращаемого вызовом `features`. Это позволяет избежать неопределенного поведения, с которым мы сталкивались ранее. Затем к битам, на которые указывает указатель, применяется индексация с индексом 5 и полученное значение типа `bool` используется для инициализации переменной `highPriority`.
В примере с `Matrix` идиома явно типизированного инициализатора выглядит следующим образом:
```cpp
auto sum = static_cast<Matrix>(m1 + m2 + m3 + m4);
```
Применение идиомы не ограничивается инициализаторами, производимыми прокси-классами. Она может быть полезной для того, чтобы подчеркнуть, что вы сознательно создаете переменную типа, отличного от типа, генерируемого инициализирующим выражением. Предположим, например, что у вас есть функция для вычисления некоторого значения отклонения:
```cpp
double calcEpsilon(); // Возвращает значение отклонения
```
Очевидно, что `calcEpsilon` возвращает значение `double`, но предположим, что вы знаете, что для вашего приложения точности `float` вполне достаточно и для вас существенна разница в размерах между `float` и `double`. Вы можете объявить переменную типа `float` для хранения результата функции `calcEpsilon`
```cpp
float ep = calcEpsilon(); // Неявное преобразование
                          // double -> float
```
но вряд ли это выражает мысль "я намеренно уменьшаю точность значения, возвращенного функцией". Зато это делает идиома явной типизации инициализатора:
```cpp
auto ep = static_cast<float>(calcEpsilon());
```
Аналогичные рассуждения применяются, если у вас есть выражение с плавающей точкой, которое вы преднамеренно сохраняете как целочисленное значение. Предположим, что вам надо вычислить индекс элемента в контейнере