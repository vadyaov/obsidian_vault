Дубликаты:
1; 3; 4; 5; 6; 7; 8; 11; 12

Оригиналы:
0; 1; 10; 11; 12; 2; 3

Без доработки: 0; 1; 10; 11; 12; 2; 3; 4; 5; 6; 7; 8; 9;

Metrics:
- device_name -- string
- read_latency -- histogram
- read_size -- histogram
- write_io_error -- number
- write_latency -- histogram
- write_size -- histogram

### Class DiskIoMgr
Управляющий объект, который планирует выполнение операций ввода-вывода для всех запросов на всех дисках и удаленных файловых системах (таких как S3). Каждый запрос сопоставляется с одним или несколькими объектами RequestContext, каждый из которых имеет свою очередь диапазонов сканирования и/или записи.

API разделяет запросы на диапазоны сканирования/записи (неблокирующие) и чтение данных (блокирующие). DiskIoMgr имеет рабочие потоки, которые будут выполнять чтение и запись на диск/HDFS/удаленные файловые системы, что позволяет чередовать операции ввода-вывода и загрузку процессора. Это дает возможность максимально задействовать все диски и все ядра.

Все публичные API потокобезопасны. Нельзя вызывать любые API после того, как метод UnregisterContext() завершит выполнение.

**Для читателей:**
Мы можем смоделировать эту задачу как проблему с несколькими производителями (потоки для каждого диска) и несколькими потребителями (диапазоны сканирования).
Существует несколько очередей, которые необходимо синхронизировать.
Концептуально есть две очереди:
1. Очередь для каждого диска: содержит очередь читателей, которым требуется чтение.
2. Очередь готовых буферов для каждого диапазона сканирования: содержит буферы, которые были прочитаны и готовы для вызова.

- Очередь дисков содержит очередь читателей и управляется по круговому принципу.
- Читатели сопоставляются с узлами сканирования.
- Затем читатель содержит очередь диапазонов сканирования.
- Вызывающая сторона запрашивает у IoMgr следующий диапазон для обработки.
- Затем IoMgr выбирает лучший диапазон для чтения, исходя из активности диска, и начинает читать и ставить в очередь буферы для этого диапазона.

**Для писателей**:  
Данные записываются через метод `RequestContext::AddWriteRange()`. Это неблокирующая операция, которая добавляет `WriteRange` в очередь для каждого диска. После завершения записи вызывается обратный вызов в `WriteRange`.
Внутри `IoMgr` память для записи не выделяется, и копии данных не создаются. Клиент несет ответственность за обеспечение корректности данных для записи. Если файл для записи не существует, он будет создан.

**Для операций с файлами**:  
Помимо операций для читателей и писателей, существует специальный тип операций — операции с файлами, которые позволяют выполнять операции ввода-вывода (загрузку или получение) для всего файла между локальной и удаленной файловыми системами.
Каждая операция с файлом ставится в очередь для операций с файлами и обрабатывается потоком диска. После завершения операции вызывается функция обратного вызова для диапазона операции с файлом. Для передачи данных выделяется блок памяти, и память освобождается сразу после завершения операции.

Существует несколько ключевых методов для сканирования данных с помощью IoMgr:  
1. `RequestContext::StartScanRange()`: добавляет диапазон в `IoMgr` для немедленного запуска.  
2. `RequestContext::AddScanRanges()`: добавляет диапазоны в `IoMgr`, которые читатель хочет сканировать, но не запускает их до тех пор, пока не будет вызван метод `RequestContext::GetNextUnstartedRange()`.  
3. `RequestContext::GetNextUnstartedRange()`: возвращает вызывающему объекту следующий диапазон сканирования, который он должен обработать.
4. `ScanRange::GetNext()`: возвращает следующий буфер для данного диапазона, блокируя выполнение до тех пор, пока данные не станут доступны.

Потоки дисков не синхронизируются друг с другом.
Читатели и писатели также не синхронизируются друг с другом.
Для каждой очереди контекстов запросов и каждой очереди дисков имеется блокировка и условная переменная.  

ВАЖНО: когда требуется обе блокировки, сначала захватывается блокировка контекста, а затем блокировка диска.

Планирование: если существует несколько контекстов запросов с работой для одного диска, они планируются по круговому принципу. Несколько потоков дисков могут работать с одним и тем же контекстом запроса.
В каждый момент времени один поток диска обрабатывает ровно один диапазон запросов. Если для одного контекста запланировано несколько диапазонов сканирования, они обрабатываются по круговому принципу.  

Если для диска существует несколько диапазонов чтения и записи, чтение всегда чередуется с записью, т.е. чтение и запись чередуются.
Если для одного диска в очереди несколько диапазонов записи, они будут обрабатываться потоками дисков по порядку, но могут завершаться в любом порядке.
Порядок выполнения записей на разных дисках не гарантируется. Стратегия планирования такая же и для диапазонов операций с файлами, но эти диапазоны находятся в отдельной очереди по сравнению с диапазонами чтения (сканирования) или записи.

### Управление ресурсами: 
IoMgr разработан для того, чтобы распределять доступные ресурсы дискового ввода-вывода между множеством клиентов и эффективно использовать доступную пропускную способность I/O. Интерфейсы IoMgr позволяют клиентам самостоятельно управлять использованием процессора и памяти, в то время как IoMgr управляет распределением I/O возможностей различных устройств между диапазонами сканирования разных клиентов.

Клиенты IoMgr могут одновременно работать с несколькими диапазонами сканирования, чтобы максимизировать использование CPU и I/O. Клиенты могут вызывать RequestContext::GetNextUnstartedRange(), чтобы запустить столько параллельных диапазонов сканирования, сколько требуется. Как только диапазон сканирования возвращен через GetNextUnstartedRange(), вызывающий объект должен выделить необходимую память для буферов, после чего IoMgr начнет заполнять буферы данными, а вызывающий объект может одновременно обрабатывать эти данные.

### Управление буферами:
Буферы для чтения могут быть: 
1. Выделены от имени вызывающего объекта с помощью AllocateBuffersForRange() ("выделенные IoMgr"),  
2. Закэшированы в HDFS, если диапазон был прочитан из кэша HDFS, или  
3. Предоставлены клиентом и достаточно велики, чтобы вместить весь объем данных диапазона.  

Все типы буферов обернуты в BufferDescriptors перед возвращением вызывающему объекту. 

### Поддержка кэширования:
Диапазоны сканирования содержат метаданные о том, закэшированы ли они на DN. В таких случаях используется API HDFS для чтения данных из кэша без копирования. 

### Поддержка удаленных файловых систем (например, S3):
Удаленные файловые системы рассматриваются как "удаленные диски". Для каждого типа удаленной файловой системы существует отдельная очередь диска, а также открываются несколько параллельных соединений для повышения пропускной способности.

### Структура реализации:
- Все клиентские API определены в данном файле, request-ranges.h и request-context.h.
- Некоторые внутренние классы определены в disk-io-mgr-internal.h.
- API ScanRange реализованы в scan-range.cc.
- API RequestContext реализованы в request-context.cc.
- Потоковые API и общие функции реализованы в disk-io-mgr.cc.
- Кэш обработчиков реализован в handle-cache{.inline,}.h.