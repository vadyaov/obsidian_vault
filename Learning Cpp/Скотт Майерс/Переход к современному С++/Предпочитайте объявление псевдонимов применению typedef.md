Ни один из нас не увлечется многократным написанием типов наподобие `std::unique_ptr<std::unordered_map<std::string, std::string>>`. Избежать такой трагедии несложно, достаточно использовать `typedef`:
```cpp
typedef std::unique_ptr<std::unordered_map<std::string, std::string>> UPtrMapSS;
```
Стандарт С++11 предлагает еще и *объявление псевдонима* (alias declaration):
```cpp
using UPtrMapSS = 
	std::unique_ptr<std::unordered_map<std::string, std::string>>;
```
С учетом того, что `typedef` и объявление псевдонима делают в точности одно и то же, разумно задаться вопросом "А есть ли какое-то техническое основание для того, чтобы предпочесть один способ другому?".

Да, есть, но перед тем как я его укажу, замечу, что многие программисты считают объявление псевдонима более простым для восприятия при работе с типами, включающими указатели на функции:
```cpp
// FP является синонимом для указателя на функцию, принимающую
// int и const std::string& и ничего не возвращающую
typedef void (*FP)(int, const std::string&);

// То же самое, но как объявление псевдонима
using FP = void (*)(int, const std::string&);
```
Конечно, ни одна из разновидностей не оказывается существенно проще другой, а ряд программистов тратит немало времени для того, чтобы верно записать синонимы для типов указателей на функции, так что пока что убедительных причин для предпочтения объявления псевдонима нет.

Однако убедительная причина все же существует, и называется она - шаблоны. В частности, объявления псевдонимов могут быть шаблонизированы (и в этом случае они называются шаблонами псевдонимов), в то время как `typedef` - нет. Это дает программистам на С++11 простой механизм для выражения того, что в С++98 можно было выразить только хакерскими способами, с помощью `typedef`, вложенных в шаблонные `struct`. Рассмотрим, например, определение синонима для связанного списка, который использует пользовательский распределитель памяти `MyAlloc` В случае шаблонов псевдонимов это просто:
```cpp
// MyAllocKist<T> является синонимом для std::list<T, MyAlloc<T>>:
template<typename T>
	using MyAllocList = std::list<T, MyAlloc<T>>;

MyAllocList<Widget> lw;    // Клиентский код
```
В случае `typedef` эти семечки приходится сначала долго растить:
```cpp
// MyAllocList<T>::type - синоним для std::list<T, MyAlloc<T>>;
template<typename T>
struct MyAllocList {
	typedef std::list<T, MyAlloc<T>> type;
};

MyAllocList<Widget>::type lw;  // Клиентский код
```
К тому же, если вы хотите использовать `typedef` в шаблоне для создания связанного списка, хранящего объекты типа, указанного параметром шаблона, имя, указанное в `typedef`, следует предварять ключевым словом `typename`:
```cpp
template<typename T>
class Widget {
private:
	typename MyAllocList<T>::type list;
};
```
Здесь `MyAllocList<T>::type` ссылается на тип, который зависит от параметра типа шаблона (Т). Тем самым `MyAllocList<T>::type` является *зависимым типом* (dependent type), а одно из многих милых правил С++ требует, чтобы имена зависимых типов предварялись ключевым словом `typename`.
Если `MyAllocList` определен как шаблон псевдонима, это требование использования ключевого слова `typename` убирается (как и громоздкий суффикс "::type"):
```cpp
template<typename T>
	using MyAllocList = std::list<T, MyAlloc<T>>;

template<typename T>
class Widget {
private:
	MyAllocList<T> list;
}
```
Для вас `MyAllocList<T>` (т.е. использование псевдонима шаблона) может выглядеть как зависимый от параметра шаблона `T`, как и `MyAllocList<T>::type`, но вы не компилятор. Когда компилятор обрабатывает шаблон `Widget` и встречает использование `MyAllocList<T>` (т.е. использование шаблона псевдонима), он знает, что `MyAllocList<T>` является именем типа, поскольку `MyAllocList` является шаблоном псевдонима: он *обязан* быть именем типа. Тем самым `MyAllocList<T>` оказывается *независимым типом*, и спецификатор `typename` не является ни требуемым, ни разрешенным.
С другой стороны, когда компилятор видит `MyAllocList<T>::type` (т.е. использование вложенных `typedef`) в шаблоне `Widget`, он не может знать наверняка, что эта конструкция именует тип, поскольку это может быть специализация `MyAllocList`, с которой он еще не встречался и в которой `MyAllocList<T>::type` ссылается на нечто, отличное от типа. Это звучит глупо, но не вините компиляторы за то, что они рассматривают такую возможность. В конце концов, это люди пишут код.

Например, некая заблудшая душа вполне в состоянии написать следующее:
```cpp
class Wine { ... };

template<>                 // Специализация MyAllocList в
class MyAllocList<Wine> {  // которой T представляет собой Wine
private:
	enum class WineType {White, Red, Rose};
	WineType type;          // type представляет собой данные-член!
};
```
`MyAllocList<Wine>::type` не является типом. Если `Widget` инстанцирован с `Wine`, `MyAllocList<T>::type` в шаблоне `Widget` представляет собой данные-член, а не тип. Ссылается ли `MyAllocList<T>::type` на тип в шаблоне `Widget`, зависит от того, чем является `T`, а потому компиляторы требуют, чтобы вы точно указывали, что это тип, предваряя его ключевым словом `typename`.

Если вы занимаетесь метапрограммированием с использованием шаблонов (template metaprogramming - TMP), то вы, скорее всего, сталкивались с необходимостью получать параметры типов шаблонов и создавать из них новые типы. Например, для некоторого заданного типа `T` вы можете захотеть удалить квалификатор `const` или квалификатор ссылки, содержащийся в `T`, например преобразовать `const std::string&` в `std::string`. Вы можете также захотеть добавить `const` к типу или преобразовать его в lvalue-ссылку, например, превращая `Widget` в `const Widget` или в `Widget&`.
>[!info] TODO
>Если вы еще не занимались TMP, это плохо, потому что, если вы действительно хотите быть эффективным программистом на С++, вы должны быть знакомы как минимум с основами этого этого аспекта С++.
>Вы можете увидеть примеры TMP в действии, включая различные преобразования типов, о которых я упоминал, в разделах [[Азы std move и std forward]] и [[Знакомство с альтернативами перегрузки для универсальных ссылок]]

C++11 дает вам инструменты для такого рода преобразований в виде *свойств типов* (type traits), набора шаблонов в заголовочном файле `<type_traits>`. В нем вы найдете десятки свойств типов; не все из них выполняют преобразования типов, но те, которые это делают, предлагают предсказуемый интерфейс. Для заданного типа `T`, к которому вы хотели бы применить преобразование, результирующий тип имеет вид `std::преобразование<T>::type`, например:
```cpp
std::remove_const<T>::type          // Дает T из const T
std::remove_reference<T>::type      // Дает T из T& и T&&
std::add_lvalue_reference<T>::type  // Дает T& из T
```
Комментарии просто резюмируют, что делают эти преобразования, так что не принимайте их слишком буквально. Перед тем как использовать их в своем проекте, я настоятельно рекомендую ознакомиться с их точной спецификацией.
Обратите внимание на то, что каждое преобразование завершается "::type". Если вы применяет их к параметру типа в шаблоне (что практически всегда является их применением в реальном коде), то вы также должны предварять каждое их применение ключевым словом `typename`. Причина обоих этих синтаксических требований заключается в том, что свойства типов в С++11 реализованы как вложенные `typedef` внутри шаблонных структур `struct`. Да, это так - они реализованы с помощью технологии, о которой я говорю, что она уступает шаблонам псевдонимов!

Тому есть исторические причины, но здесь мы их опустим. Псевдонимы имеют общий вид: для каждого преобразования С++11 `std::преобразование<T>::type` имеется соответствующий шаблон псевдонима С++14 с именем `std::преобразование_t`:
```cpp
std::remove_const<T>::type         // C++11
std::remove_const_t<T>             // C++14
std::remove_reference<T>::type     // C++11
std::remove_reference_t<T>         // C++14
std::add_value_reference<T>::type  // C++11
std::add_lvalue_reference_t<T>     // C++14
```
Конструкции С++11 остаются в силе в С++14, но я не знаю, зачем вам может захотеться их использовать. По крайней мере всегда можно сделать так:
```cpp
template<class T>
using remove_const_t = typename remove_const<T>::type;
```
и аналогично для других. Что может быть проще?

>[!note] Следует запомнить
>- В отличие от объявлений псевдонимов, `typedef` не поддерживает шаблонизацию.
>- Шаблоны псевдонимов не требуют суффикса "::type", а в шаблона - префикса `typename`, часто требуемого при обращении к `typedef`.
>- C++14 предлагает шаблоны псевдонимов для всех преобразований свойств типов С++11.