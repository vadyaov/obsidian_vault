В зависимости от вашей точки зрения выбор синтаксиса для инициализации объектов в С++11 либо очень богатый, либо запутанный и беспорядочный. Как правило, инициализирующие значения указываются с помощью круглых скобок, знака равенства или фигурных скобок:
```cpp
int x(0);
int y = 0;
int z{0};
```
Во многих случаях можно использовать знак равенства и фигурные скобки одновременно:
```cpp
int z = {0};
```
В оставшейся части данного раздела я в основном буду игнорировать синтаксис, в котором одновременно используются знак равенства и фигурные скобки, поскольку С++ обычно трактует его так же, как и версию только с фигурными скобками.

Сторонники "полного беспорядка" указывают на то, что применение знака равенства для инициализации часто сбивает с толку новичков в С++,  которые считают, что имеют дело с присваиванием, хотя на самом деле это не так. Для встроенных типов наподобие `int` эта разница носит чисто академический характер, но в случае пользовательских типов очень важно отличать инициализацию от присваивания, поскольку при этом вызываются различные функции:
```cpp
Widget w1;       // Вызов ctor по умолчанию
Widget w2 = w1;  // Не присваивание, а копирующий конструктор
w1 = w2;         // Присваивание; вызов оператора operator=()
```
Даже при наличии нескольких синтаксисов инициализации существовали определенные ситуации, когда в С++98 не было возможности выразить желаемую инициализацию. Например, было невозможно прямо указать, что контейнер STL должен быть создан содержащим определенный набор значений (например, 1, 3 и 5).

Для устранения путаницы из-за нескольких синтаксисов инициализации и решения проблемы охвата всех сценариев инициализации С++11 вводит *унифицированную инициализацию* (uniform initialization). Унифицированная инициализация - это идея. Фигурная инициализация - это синтаксическая конструкция.

Фигурная инициализация позволяет выразить то, что было невозможно выразить ранее. С помощью фигурных скобок легко указать начальное содержимое контейнера:
```cpp
std::vector<int> v{1, 3, 5};
```
Фигурные скобки могут также использоваться для указания значений инициализации по умолчанию для нестатических членов-данных. Эта возможность - новая в С++11 - может использоваться с синтаксисом "=", но не с круглыми скобками:
```cpp
class Widget {
...
private:
	int x {0}; // OK, значение х по умолчанию равно 0
	int y = 0; // Тоже ОК
	int z(0);  // Ошибка!
}
```
С другой стороны, некопируемые объекты (например, `std::atomic`) могут быть инициализированы с помощью фигурных или круглых скобок, но не с помощью знака равенства.
```cpp
std::atomic<int> ai1{0}; // OK
std::atomic<int> ai2(0); // OK
std::atomic<int> ai3 = 0; // Ошибка!
```
Легко понять, почему фигурная инициализация названа "унифицированной". Из трех способов обозначения выражений инициализации только фигурные скобки могут использоваться везде.

Новая возможность фигурной инициализации заключается в том, что она запрещает делать *сужающие преобразования* среди встроенных типов. Если значение выражения в фигурном инициализаторе не может быть гарантированно выражено типом инициализируемого объекта, код не компилируется.
```cpp
double x, y, z;
...
int sum{x + y + z}; // Ошибка! Сумма double может
                    // не выражаться с помощью int
```
Инициализация с использованием круглых скобок и знака равенства не выполняет проверку сужающего преобразования, поскольку это может привести к неработоспособности большого количества старого кода.

Обращает на себя внимание еще одна особенность фигурной инициализации - она не подвержена *наиболее неприятному анализу* в С++. Побочным эффектом правила С++, согласно которому все, что в ходе синтаксического анализа может рассматриваться как объявление, должно рассматриваться как таковое, является так называемый наиболее неприятный анализ, который чаще всего досаждает разработчикам, когда они хотят создать объект по умолчанию, а в результате получают объявление функции. Корень проблемы кроется в том, что если вы хотите вызвать конструктор с аргументом, вы делаете это примерно следующим образом:
```cpp
Widget w1(10); // Вызов конструктора Widget с аргументом 10
```
Но если вы пытаетесь вызвать конструктор `Widget` без аргументов с помощью аналогичного синтаксиса, то фактически объявляете функцию вместо объекта:
```cpp
Widget w2(); // Синтаксический анализ рассматривает это как
             // объявление функции w2, возвращающей Widget
```
Функции не могут быть объявлены с использованием фигурных скобок для списка параметров, так что конструирование объекта по умолчанию с применением фигурных скобок такой проблемы не вызовет:
```cpp
Widget w3{}; // Вызов конструктора Widget без аргументов
```
Таким образом, в пользу фигурной инициализации имеется много "за". Это синтаксис, который может использоваться в самых разнообразных контекстах, предотвращающий неявные сужающие преобразования и не подверженный неприятностям с синтаксическим анализом С++. Тройное "за"! Так почему бы не озаглавить раздел просто "Используйте синтаксис фигурной инициализации"?

Основной недостаток фигурной инициализации - временами сопровождающее ее удивительное поведение.