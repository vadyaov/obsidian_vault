В зависимости от вашей точки зрения выбор синтаксиса для инициализации объектов в С++11 либо очень богатый, либо запутанный и беспорядочный. Как правило, инициализирующие значения указываются с помощью круглых скобок, знака равенства или фигурных скобок:
```cpp
int x(0);
int y = 0;
int z{0};
```
Во многих случаях можно использовать знак равенства и фигурные скобки одновременно:
```cpp
int z = {0};
```
В оставшейся части данного раздела я в основном буду игнорировать синтаксис, в котором одновременно используются знак равенства и фигурные скобки, поскольку С++ обычно трактует его так же, как и версию только с фигурными скобками.

Сторонники "полного беспорядка" указывают на то, что применение знака равенства для инициализации часто сбивает с толку новичков в С++,  которые считают, что имеют дело с присваиванием, хотя на самом деле это не так. Для встроенных типов наподобие `int` эта разница носит чисто академический характер, но в случае пользовательских типов очень важно отличать инициализацию от присваивания, поскольку при этом вызываются различные функции:
```cpp
Widget w1;       // Вызов ctor по умолчанию
Widget w2 = w1;  // Не присваивание, а копирующий конструктор
w1 = w2;         // Присваивание; вызов оператора operator=()
```
Даже при наличии нескольких синтаксисов инициализации существовали определенные ситуации, когда в С++98 не было возможности выразить желаемую инициализацию. Например, было невозможно прямо указать, что контейнер STL должен быть создан содержащим определенный набор значений (например, 1, 3 и 5).

Для устранения путаницы из-за нескольких синтаксисов инициализации и решения проблемы охвата всех сценариев инициализации С++11 вводит *унифицированную инициализацию* (uniform initialization). Унифицированная инициализация - это идея. Фигурная инициализация - это синтаксическая конструкция.

Фигурная инициализация позволяет выразить то, что было невозможно выразить ранее. С помощью фигурных скобок легко указать начальное содержимое контейнера:
```cpp
std::vector<int> v{1, 3, 5};
```
Фигурные скобки могут также использоваться для указания значений инициализации по умолчанию для нестатических членов-данных. Эта возможность - новая в С++11 - может использоваться с синтаксисом "=", но не с круглыми скобками:
```cpp
class Widget {
...
private:
	int x {0}; // OK, значение х по умолчанию равно 0
	int y = 0; // Тоже ОК
	int z(0);  // Ошибка!
}
```
С другой стороны, некопируемые объекты (например, `std::atomic`) могут быть инициализированы с помощью фигурных или круглых скобок, но не с помощью знака равенства.
```cpp
std::atomic<int> ai1{0}; // OK
std::atomic<int> ai2(0); // OK
std::atomic<int> ai3 = 0; // Ошибка!
```
Легко понять, почему фигурная инициализация названа "унифицированной". Из трех способов обозначения выражений инициализации только фигурные скобки могут использоваться везде.

Новая возможность фигурной инициализации заключается в том, что она запрещает делать *сужающие преобразования* среди встроенных типов. Если значение выражения в фигурном инициализаторе не может быть гарантированно выражено типом инициализируемого объекта, код не компилируется.
```cpp
double x, y, z;
...
int sum{x + y + z}; // Ошибка! Сумма double может
                    // не выражаться с помощью int
```
Инициализация с использованием круглых скобок и знака равенства не выполняет проверку сужающего преобразования, поскольку это может привести к неработоспособности большого количества старого кода.

Обращает на себя внимание еще одна особенность фигурной инициализации - она не подвержена *наиболее неприятному анализу* в С++. Побочным эффектом правила С++, согласно которому все, что в ходе синтаксического анализа может рассматриваться как объявление, должно рассматриваться как таковое, является так называемый наиболее неприятный анализ, который чаще всего досаждает разработчикам, когда они хотят создать объект по умолчанию, а в результате получают объявление функции. Корень проблемы кроется в том, что если вы хотите вызвать конструктор с аргументом, вы делаете это примерно следующим образом:
```cpp
Widget w1(10); // Вызов конструктора Widget с аргументом 10
```
Но если вы пытаетесь вызвать конструктор `Widget` без аргументов с помощью аналогичного синтаксиса, то фактически объявляете функцию вместо объекта:
```cpp
Widget w2(); // Синтаксический анализ рассматривает это как
             // объявление функции w2, возвращающей Widget
```
Функции не могут быть объявлены с использованием фигурных скобок для списка параметров, так что конструирование объекта по умолчанию с применением фигурных скобок такой проблемы не вызовет:
```cpp
Widget w3{}; // Вызов конструктора Widget без аргументов
```
Таким образом, в пользу фигурной инициализации имеется много "за". Это синтаксис, который может использоваться в самых разнообразных контекстах, предотвращающий неявные сужающие преобразования и не подверженный неприятностям с синтаксическим анализом С++. Тройное "за"! Так почему бы не озаглавить раздел просто "Используйте синтаксис фигурной инициализации"?

Основной недостаток фигурной инициализации - временами сопровождающее ее удивительное поведение. Такое поведение вырастает из необыкновенно запутанных взаимоотношений между фигурной инициализацией, `std::initializer_list` и разрешением перегрузки конструкторов. Их взаимодействие может привести к коду, который, как кажется, должен делать что-то одно, а в результате делает что-то совсем другое.

В вызовах конструктора круглые скобки и фигурные скобки имеют один и тот же смысл, пока в конструкторах не принимают участие параметры `std::initializer_list`:
```cpp
class Widget {
public:
	Widget(int i, bool b);    // Конструкторы не имеют параметров
	Widget(int i, double d);  // std::initializer_list
};

Widget w1(10, true); // Вызов первого конструктора
Widget w2{10, true}; // Вызов первого конструктора
Widget w3(10, 5.0);  // Вызов второго конструктора
Widget w4{10, 5.0};  // Вызов второго конструктора
```
Если же один или несколько конструкторов объявляют параметр типа `std::initializer_list`, вызовы, использующие синтаксис фигурной инициализации, строго предпочитают перегрузки, принимающие `std::initializer_list`. *Строго*. Если у компилятора есть любой способ истолковать вызов с фигурным инициализатором как конструктор, принимающий `std::initializer_list`, он использует именно это толкование. Если класс `Widget` выше дополнить конструктором, принимающим, например, `std::initializer_list<long double>`
```cpp
class Widget {
public:
	Widget(int i, bool b);   // Как и ранее
	Widget(int i, double d); // Как и ранее

	Widget(std::initializer_list<long double> il); // Добавлен
};
```
то w2 и w4 будут созданы с помощью нового конструктора, несмотря на то что тип элементов `std::initializer_list` (в данном случае - `long double`) хуже соответствует обоим аргументам по сравнению с конструкторами, не принимающими `std::initializer_list`!
```cpp
Widget w1(10, true); // Вызов первого конструктора
Widget w2{10, true}; // Вызов третьего конструктора
                     // 10 и true преобразуются в long double
Widget w3(10, 5.0);  // Вызов второго конструктора
Widget w4{10, 5.0};  // Вызов третьего конструктора
                     // 10 и 5.0 преобразуются в long double
```
Даже то, что в обычной ситуации представляет собой копирующий или перемещающий конструктор, может быть перехвачено конструктором с `std::initializer_list`:
```cpp
class Widget {
public:
	Widget(int i, bool b);   // Как и ранее
	Widget(int i, double d); // Как и ранее
	Widget(std::initializer_list<long double> il); // Как и ранее

	operator float() const; // Преобразование во float

};

Widget w5(w4);            // Использует круглые скобки, вызывает
						  // копирующий конструктор
Widget w6{w4};            // Использует фигурные скобки, вызов
                          // конструктора с std::initializer_list
                          // (w4 преобразуется во float, а float
                          // преобразуется в long double)
Widget w7(std::move(w4)); // Использует круглые скобки, вызывает
                          // перемещающий конструктор
Widget w8{std::move(w4)}; // Использует фигурные скобки, вызов
                          // конструктора c std::initializer_list
                          // (все как для w6)
```
Определение компилятором соответствия фигурных инициализаторов конструкторам с `std::initializer_list` настолько строгое, что доминирует даже тогда, когда конструктор с `std::initializer_list` с наилучшим соответствием не может быть вызван, например:
```cpp
class Widget {
public:
	Widget(int i, bool b);   // Как и ранее
	Widget(int i, double d); // Как и ранее
	Widget(std::initializer_list<bool> il); // Теперь bool

	// Нет функций неявного преобразования
};

Widget w{10, 5.0};  // Ошибка! Требуется сужающее преобразование
```
Здесь компилятор игнорирует первые два конструктора (второй из которых в точности соответствует обоим типам аргументов) и пытается вызвать конструктор, получающий аргумент типа `std::initializer_list<bool>`. Вызов этого конструктора требует преобразования значений `int (10)` и `double (5.0)` в `bool`. Оба эти преобразования являются сужающими (`bool` не может в точности представить ни первое, ни второе значения), а так как сужающие преобразования запрещены в фигурных инициализаторах, вызов является некорректным, и код отвергается.

И только если нет никакой возможности преобразовать типы аргументов в фигурном инициализаторе в типы `std::initializer_list`, компилятор возвращается к нормальному разрешению перегрузки. Например, если мы заменим конструктор с `std::initializer_list<bool>` конструктором, принимающим `std::initializer_list<std::string>`, то кандидатами на вызов вновь станут конструкторы, не принимающие `std::initializer_list` (поскольку нет никакого способа преобразовать `int` и `bool` в `std::string`):
```cpp
class Widget {
public:
	Widget(int i, bool b);   // Как и ранее
	Widget(int i, double d); // Как и ранее
	Widget(std::initializer_list<std::string> il); // Теперь std::string

	// Нет функций неявного преобразования
};

Widget w1(10, true); // Круглые скобки. Вызов первого конструктора
Widget w2{10, true}; // Фигурные скобки. Вызов первого конструктора
Widget w3(10, 5.0);  // Круглые скобки. Вызов второго конструктора
Widget w4{10, 5.0};  // Фигурные скобки. Вызов второго конструктора
```
Это приводит нас к завершению изучения фигурных инициализаторов и перегрузки конструкторов, но есть еще один интересный предельный случай, который хотелось бы рассмотреть. Предположим, что вы используете пустые фигурные скобки для создания объекта, который поддерживает конструктор по умолчанию и конструктор с `std::initializer_list`. Что при этом будут означать пустые фигурные скобки? Если они означают "без аргументов", будет вызван конструктор по умолчанию, но если они означают "пустой `std::initializer_list`", то будет вызван конструктор с `std::initializer_list` без элементов.

Правило заключается в том, что будет вызван конструктор по умолчанию. Пустые фигурные скобки означают отсутствие аргументов, а не пустой `std::initializer_list`
```cpp
class Widget {
public:
	// Конструктор по умолчанию
	Widget();
	// Конструктор с std::initializer_list
	Widget(std::initializer_list<int> il);

		// Нет функций неявного преобразования
};

Widget w1;   // Вызов конструктора по умолчанию
Widget w2{}; // Вызова конструктора по умолчанию
Widget w3(); // Трактуется как объявление функции!
```
Если вы *хотите* вызвать конструктор с пустым `std::initializer_list`, то это можно сделать, передавая пустые фигурные скобки в качестве аргумента конструктора в круглых или фигурных скобках, окружающих передаваемые вами:
```cpp
Widget w4({});  // Вызов конструктора с пустым std::initializer_list
Widget w5({});  // То же самое
```
Сейчас, когда кажущиеся магическими правила фигурной инициализации, `std::initializer_list` и перегрузки конструкторов переполняют ваш мозг, вы можете удивиться, какое большое количество информации влияет на повседневное программирование. На самом деле даже больше, чем вы думаете, потому что одним из классов, на которые все это оказывает непосредственное влияние, является `std::vector`. Класс `std::vector` имеет конструктор без `std::initializer_list`, который позволяет вам указать начальный размер контейнера и значение, присваиваемое каждому из его элементов; но при этом имеется также конструктор, принимающий `std::initializer_list` и позволяющий указать начальные значения контейнера. Если вы создаете `std::vector` числового типа (например, `std::vector<int>`) и передаете ему два аргумента, то при использовании круглых и фигурных скобок вы получите совершенно разные результаты:
```cpp
std::vector<int> v1(10, 20); // 10 элементов, значение каждого равно 20
std::vector<int> v2{10, 20}; // 2 элемента - 10 и 20
```

Имеется два основных вывода из этого обсуждения.

**Во-первых**, как автор класса вы должны быть осведомлены о том, что если ваш набор перегружаемых конструкторов включает один или несколько конструкторов, использующих `std::initializer_list`, то клиентский код с фигурной инициализацией может рассматривать только перегрузки с `std::initializer_list`. В результате лучше проектировать конструкторы так, чтобы перегрузка не зависела от того, используете вы круглые или фигурные скобки. Другими словами, вынесите уроки из того, что сейчас рассматривается как ошибка дизайна интерфейса класса `std::vector`, и проектируйте свои классы так, чтобы избегать подобных ошибок.

**Во-вторых**, в качестве клиента класса вы должны тщательно выбирать между круглыми и фигурными скобками при создании объектов. Большинство разработчиков в конечном итоге выбирают один вид скобок как применяемый по умолчанию, а другой - только при необходимости. 

Применение по умолчанию фигурных скобок привлекает их непревзойденным диапазоном применимости, запретом применения сужающих преобразований и их иммунитетом к особенностям синтаксического анализа. 

Круглые скобки привлекательны своей согласованностью с синтаксическими традициями С++98, тем, что позволяют избегать проблем с выводом `auto` как `std::initializer_list`, и уверенностью, что вызовы при создании объектов не приведут к случайным вызовам конструкторов с `std::initializer_list`.

Если вы автор шаблона, противостояние в применении круглых и фигурных скобок может быть особенно неприятным, потому что в общем случае невозможно сказать, какие скобки должны использоваться. Предположим, например, что вы хотите создать объект произвольного типа с произвольным количеством аргументов. Использование шаблонов с переменным количеством параметров позволяет сделать это концептуально достаточно просто:
```cpp
template<typename T, typename... Ts> // тип объекта и тип аргументов
void doSomeWork(Ts&&... params)
{
	Создание локального объекта T из params...
}
```
Есть два способа превратить строку псевдокода в реальный код (см. в [[Используйте std move для rvalue-ссылок, а std forward - для универсальных ссылок|разделе]]информацию о `std::forward`):
```cpp
T localObject(std::forward<Ts>(params)...); // круглые скобки
T localObject{std::forward<Ts>(params)...}; // фигурные скобки
```
Рассмотрим следующий вызывающий код:
```cpp
std::vector<int> v;
...
doSomeWork<std::vector<int>>(10, 20);
```
Если `doSomeWork` использует при создании объекта `localObject` круглые скобки, в результате будет получен `std::vector` с 10 элементами. Если же `doSomeWork` использует фигурные скобки, то результатом будет `std::vector` с двумя элементами. Какой из этих вариантов корректен? Автор `doSomeWork` не может этого знать. Это может знать только вызывающий код.

Это именно так проблема, которая встает перед функциями стандартной библиотеки `std::make_unique` и `std::make_shared`. Эти функции решают проблему, используя круглые скобки и документируя это решение как части своих интерфейсов.

>[!note] Следует запомнить
>- Фигурная инициализация является наиболее широко используемым синтаксисом инициализации, предотвращающим сужающие преобразования и нечувствительным к особенностям синтаксического анализа С++.
>- В процессе разрешения перегрузки конструкторов фигурные инициализаторы соответствуют параметра `std::initializer_list`, если это возможно, даже если другие конструкторы обеспечивают лучшее соответствие.
>- Примером, в котором выбор между круглыми и фигурными скобками приводит к значительно отличающимся результатам, является создание `std::vector<числовой тип>` с двумя аргументами.
>- Выбор между круглыми и фигурными скобками для создания объектов внутри шаблонов может быть очень сложным.