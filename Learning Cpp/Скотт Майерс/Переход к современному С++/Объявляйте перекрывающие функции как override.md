Мир объектно-ориентированного программирования С++ вращается вокруг классов, наследования и виртуальных функций. Среди наиболее фундаментальных идей этого мира - та, что реализации виртуальных функций в производных классах *перекрывают* (override) реализации их коллег в базовых классах. Понимание того, насколько легко все может пойти наперекосяк при перекрытии функций, попросту обескураживает.

Очень часто термин "перекрытие" путают с термином "перегрузка", хотя они совершенно не связаны друг с другом. Поэтому позвольте мне пояснить, что перекрытие виртуальной функции - это то, что делает возможным вызов функции производного класса через интерфейс базового класса:
```cpp
class Base {
public:
	virtual void doWork();  // Вирутальная функция
};

class Derived : public Base {
public:
	virtual void doWork();  // Перекрывает Base::DoWork
							// Ключевое слово virtual необязательно
};

std::unique_ptr<Base> upb = 
	std::make_unique<Derived>();

upb->doWork();
```
Для осуществления перекрытия требуется выполнение нескольких условий:
- Функция базового класса должна быть виртуальной.
- Имена функций в базовом классе и производном классах должны быть одинаковыми (за исключение деструктора).
- Типы параметров функций в базовом и производном классах должны быть одинаковыми.
- Константность функций в базовом и производном классах должна совпадать.
- Возвращаемые типы и спецификации исключений функций в базовом и производном классах должны быть совместимыми.
- *Ссылочные квалификаторы* функций должны быть идентичными. Ссылочные квалификаторы функции-члена являются одной из менее известных возможностей С++11. Они позволяют ограничить использование функции-члена только объектами `lvalue` или только объектами `rvalue`. Для использования этих квалификаторов функции-члены не обязаны быть виртуальными.
```cpp
class Widget {
public:
	...
	void doWork() &;    // Эта версия doWork() применима, только если
	                    // *this представляет собой lvalue
	void doWork() &&;   // Эта версия doWork() применима, только если
	                    // *this представляет собой rvalue
};

Widget makeWidget();    // Фабричная функция (возвращает rvalue)

Widget w;               // Обычный объект (lvalue)
...
w.doWork();             // Вызов Widget::doWork для lvalue
makeWidget().doWork();  // Вызов Widget::doWork для rvalue
```
Пока что заметим, что если виртуальная функция в базовом классе имеет ссылочный квалификатор, то производный класс, перекрывающий эту функцию, должен иметь тот же ссылочный квалификатор. Если это не так, объявленные функции все еще остаются в производном классе, но они ничего не перекрывают в базовом классе.

Все эти требования к перекрытию означают, что маленькие ошибки могут привести к большим последствиям. Код, содержащий ошибки перекрытия, обычно корректен, но делает совсем не то, что хотел программист. Поэтому в данном случае нельзя полагаться на уведомления компиляторов о том, что вы что-то делаете неверно. Например, приведенный далее код является абсолютно законным и, на первый взгляд, выглядит разумным, но в нем нет перекрытия виртуально функции - нет ни одной функции производного класса, связанной с функцией базового класса.
```cpp
class Base {
public:
	virtual void mf1() const;
	virtual void mf2(int x);
	virtual void mf3() &;
	void mf4() const;
};

class Derived : public Base {
public:
	virtual void mf1();
	virtual void mf2(unsigned int x);
	virtual void mf3() &&;
	void mf4() const;
};
```
Поскольку очень важно правильно объявить производный класс перекрывающим, но при этом очень легко ошибиться, С++11 дает вам возможность явно указать, что функция производного класса предназначена для того, чтобы перекрывать функцию из базового класса: ее можно объявить как `override`. Применяя это ключевое слово к приведенному выше примеру, даст то, что код компилироваться не будет, поскольку компиляторы знают о том, что эти функции предназначены для перекрытия функций из базового класса, а потому могут определить наличие описанных нами проблем.

Стратегия использования ключевого слова `override` во всех перекрытиях производного класса способна на большее, чем просто позволить компиляторам сообщать, когда функции, которые должны быть перекрытиями, ничего не перекрывают. Они также могут помочь вам оценить последствия предполагаемого изменения сигнатуры виртуальной функции в базовом классе. Если производные классы везде используют `override`, вы можете просто изменить сигнатуру и перекомпилировать систему. Вы увидите, какие повреждения нанесли своей системе (т.е. сколько классов перестали компилироваться), и после этого сможете принять решение, стоит ли изменение сигнатуры таких хлопот. Без `override` вы должны были бы надеяться на наличие достаточно всеобъемлющих тестов, поскольку, как мы видели, виртуальные функции, которые предназначены перекрывать функции базового класса, но не делают этого, не приводят ни к какой диагностике со стороны компилятора.

В С++ всегда имелись ключевые слова, но С++11 вводит два *контекстных ключевых слова* (contextual keywords) - `override` и `final`. Эти ключевые слова являются зарезервированными, но только в некоторых контекстах. В случае `override` оно имеет зарезервированное значение только тогда, когда находится в конце объявления функции-члена.

Это все, что следует знать об `override`, но не все, что следует знать о ссылочных квалификаторах функций-членов.
Если мы хотим написать функцию, которая принимает только аргументы, являющиеся `lvalue`, мы объявляем параметр, который представляет собой не константную `lvalue`-ссылку:
```cpp
void doSomething(Widget& w); // Принимает только lvalue Widget
```
Если же мы хотим написать функцию, которая принимает только аргументы, являющиеся `rvalue`, мы объявляем параметр, который представляет собой `rvalue`- ссылку:
```cpp
void doSomething(Widget&& w); // Принимает только rvalue Widget
```
Ссылочные квалификаторы функции-члена позволяют проводить такое же различие для объектов, функции-члены которых вызываются, т.е. `*this`. Это точный аналог модификатора `const` в конце объявления функции-члена, который указывает, что объект, для которого вызывается данная функция-член (т.е. `*this`), является `const`.

Необходимость в функциях-членах со ссылочными квалификаторами нужна не так уж часто, но может и возникнуть. Предположим, например, что наш класс `Widget` имеет член-данные `std::vector`, и мы предлагаем функцию доступа, которая обеспечивает клиентам к нему непосредственных доступ:
```cpp
class Widget {
public:
	using DataType = std::vector<double>;

	DataType& data() { return values; }
	...
private:
	DataType values;
};
```
Вряд ли это наиболее инкапсулированный дизайн, который видел свет, но оставим этот вопрос в стороне и посмотрим, что происходит в следующем клиентском коде:
```cpp
Widget w;
...
auto vals1 = w.data();   // Копируем w.values в valsl
```
Возвращаемый тип `Widget::data` представляет собой `lvalue`- ссылку (`std::vector<double>&`), а поскольку `lvalue`- ссылки представляют собой `lvalue`, мы инициализируем `valsl` из `lvalue`. Таким образом, `valsl` создается копирующим конструктором из `w.values`.
Теперь предположим, что у нас имеется фабричная функция, которая создает `Widget`:
```cpp
Widget makeWidget();
```
и мы хотим инициализировать переменную с помощью `std::vector` в `Widget`, возвращенном из `makeWidget`:
```cpp
auto vals2 = makeWidget().data();   // Копирование значений в
                                    // Widget в vals2
```
И вновь `Widgets::data` возвращает `lvalue`- ссылку, и вновь `lvalue`- ссылка представляет собой `lvalue`, так что наш новый объект (`vals2`) опять является копией, построенной из `values` в объекте `Widget`. Однако в этот раз `Widget` представляет собой временный объект, возвращенный из `makeWidget` (т.е. представляет собой `rvalue`), так что копирование в него `std::vector` представляет собой напрасную трату времени. Предпочтительнее выполнить перемещение, но, поскольку `data` возвращается как `lvalue`- ссылка, правила С++ требуют, чтобы компиляторы генерировали код для копирования. (Имеется некоторый маневр для оптимизации на основе правила "как если бы", но было бы глупо полагаться на то, что ваш компилятор найдет способ им воспользоваться.)

Нам необходим способ указать, что, когда `data` вызывается для `Widget`, являющегося `rvalue`, результат также будет представлять собой `rvalue`. Использование ссылочных квалификаторов для перегрузки `data` для `Widget`, являющихся `lvalue` и `rvalue`, делает это возможным:
```cpp
class Widget {
public:
	using DataType = std::vector<double>;

	DataType& data() & { return values;  // Для lvalue Widget
	DataType&& data() && { return std::move(values); }  // Для rvalue Widget

private:
	DataType values;
};
```
Обратите внимание на разные возвращаемые типы перегрузок `data`. Перегрузка для `lvalue`- ссылки возвращает `lvalue`- ссылку (т.е. `lvalue`), а перегрузка для `rvalue`- ссылки возвращает `rvalue`- ссылку (которая, как возвращаемый тип функции, является `rvalue`). Это означает, что клиентский код ведет теперь себя так, как мы и хотели:
```cpp
auto vals1 = w.data();            // Вызывает lvalue-перегрузку
                                  // Widget::data, vals1 создается копированием
auto vals2 = makeWidget().data(); // Вызывает rvalue-перегрузку
                                  // Widget::data, vals2 создается перемещением
```
Это, конечно, хорошо, но не позвольте теплому сиянию этого хэппи-энда отвлечь вас от истинной цели этого раздела. Эта цель в том, чтобы убедить вас, что всякий раз, когда вы объявляете в производном классе функцию, предназначенную для перекрытия виртуальной функции базового класса, вы не забывали делать это с использованием ключевого слова `override`.

Кстати, если функция-член использует ссылочный квалификатор, все перегрузки этой функции также должны использовать его. Это связано с тем, что перегрузки без этих квалификаторов могут вызываться как для объектов `lvalue`, так и для объектов `rvalue`. Такие перегрузки будут конкурировать с перегрузками, имеющими ссылочные квалификаторы, так что все вызовы функции будут неоднозначными.

>[!note] Следует запомнить
>- Объявляйте перекрывающие функции как `override`.
>- Ссылочные квалификаторы функции-члена позволяют по-разному рассматривать lvalue- и rvalue- объекты