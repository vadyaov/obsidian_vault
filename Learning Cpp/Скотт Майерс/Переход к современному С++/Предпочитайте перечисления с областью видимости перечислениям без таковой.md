В качества общего правила объявление имени в фигурных скобках ограничивает видимость этого имени областью видимости, определяемой этими скобками. Но не так обстоит дело с перечислениями в С++98. Имена в таких перечислениях принадлежат области видимости, содержащей `enum`, а это означает, что ничто иное в этой области видимости не должно иметь такое же имя:
```cpp
enum Color {black, white, red}; // black, white, red находятся
                                // в той же области видимости,
                                // что и Color
auto white = false;             // ОШибка! Имя white уже
                                // объявлено в этой области
                                // видимости
```
Тот факт, что эти имена перечисления "вытекают" в область видимости, содержащую определение их `enum`, приводит к официальному термину для данной разновидности перечислений: *без области видимости* (unscoped). Их новый аналог в С++11, *перечисления с областью видимости* (scoped enum), не допускает такой утечки имен:
```cpp
enum class Color {black, white, red};

auto white = true; // OK
Color c = white;   // Ошибка! Нет имени перечисления
                   // "white" в этой области видимости
Color c = Color::white; // OK
auto c = Color::white;  // OK
```
Поскольку `enum` с областью видимости объявляются с помощью ключевого слова `class`, о них иногда говорят как о *классах перечислений*.
Снижение загрязнения пространства имен, обеспечиваемое применением перечислений с областью видимости, само по себе является достаточной причиной для предпочтения таких перечислений их аналогам без областей видимости. Однако перечисления с областью видимости имеют и второе убедительное преимущество: они существенно строже типизированы. Значения в перечислениях без областей видимости неявно преобразуются в целочисленные типы (а оттуда - в типы с плавающей точкой). Поэтому вполне законными оказываются такие семантические карикатуры:
```cpp
enum Color {black, white, red};

std::vector<std::size_t> primeFactors(std::size_t x);

Color c = red;
...
if (c < 14.5) {                     // Сравнение Color и double!
	auto factors = primeFactors(c); // Вычисление простых
									// делителей значения Color!
}
```
Добавление простого ключевого слова `class` после `enum` преобразует перечисление без области видимости в перечисление с областью видимости, и это - совсем другая история. Не имеется никаких неявных преобразований элементов перечисления с областью видимости в любой другой тип:
```cpp
enum class Coror {black, white, red};
Color c = Color::red;
...
if (c < 14.5) { // Ошибка! Сравнение Color и double
	auto factors = primeFactors(c); // Ошибка! Нельзя передать
	                                // Color в функцию, ждущую
	                                // size_t
}
```
Если хотите честно выполнить преобразование из `Color` в другой тип, воспользуйтесь явным приведением типа (`static_cast`).

Может показаться, что перечисления с областями видимости имеют и третье преимущество перед перечислениями без областей видимости, поскольку могут быть предварительно объявлены, их имена могут быть объявлены без указания перечислителей:
```cpp
enum Color;       // Ошибка!
enum class Color; // ОК
```
Это заблуждение. В С++11 переисления без областей видимости также могут быть объявлены предварительно, но только с помощью небольшой дополнительной работы, которая вытекает из того факта, что каждое перечисление в С++ имеет целочисленный *базовый тип* (underlying type), который определяется компилятором. Для перечисления без области видимости наподобие `Color`
```cpp
enum Color {black, white, red};
```
компилятор может выбрать в качестве базового типа `char`, так как он должен представлять всего лишь три значения. Однако, некоторые перечисления имеют куда больший диапазон значений, например:
```cpp
enum Status {good = 0,
			 failed = 1,
			 incomplete = 100,
			 corrupt = 200,
			 interminate = 0xFFFFFFFF
};
```
Здесь должны быть представлены значения в диапазоне от 0 до 0xFFFFFFFF. За исключением необычных машин (где `char` состоит как минимум из 32 битов), компилятор выберет для предоставления значений `Status` целочисленный тип, больший, чем `char`.

Для эффективного использования памяти компиляторы часто выбирают наименьший базовый тип, котрого достаточно для представления значений перечислителей. В некоторых случаях, когда компиляторы выполняют оптимизацию по скорости, а не по размеру, они могут выбрать не наименьший допустимый тип, но при этом они, определенно, захотят иметь возможность оптимизации размера. Для этого С++98 поддерживает только определения `enum` (в которых перечислены все значения); объявления `enum` не разрешены. Это позволяет компиляторам выбирать базовый тип для каждого `enum` до его использования.

Но невозможность предварительного объявления `enum` имеет свои недостатки. Наиболее важным из них, вероятно, является увеличение зависимостей при компиляции. Вновь обратимся к перечислению `Status`:
```cpp
enum Status {good = 0,
			 failed = 1,
			 incomplete = 100,
			 corrupt = 200,
			 interminate = 0xFFFFFFFF
};
```
Это разновидность перечисления, которая, скорее всего, будет использоваться во всей системе, а следовательно, включенная в заголовочный файл, от которой зависит каждая из частей системы. Если добавить новое значение состояния, то, вероятно, придется перекомпилировать всю систему полностью, даже если только одна подсистема - возможно, одна-единственная функция! - использует это новое значение. Это одна из тех вещей, которые программисты просто *ненавидят*. И это та вещь, которую исключает возможность предварительного объявления `enum` в С++11. Например, вот совершенно корректное объявление `enum` с областью видимости, и функции, которая получает его в качестве параметра:
```cpp
enum class Status;                 // Предварительное объявление
void continueProcessing(Status s); // и его использование
```
В данном случае заголовочный файл с объявлением не требует перекомпиляции при пересмотре `Status`. Если изменено перечисление `Status`, но поведение использующей его функции не изменилось, то не требуется и перекомпиляции реализации функции.

Но если компилятор должен знать размер `enum` до использования, то как могут перечисления C++11 быть предварительно объявлены, в то время как перечисления С++98 этого не могу? Ответ прост: базовый тип перечислений с областью видимости всегда известен, а для перечислений без областей видимости вы можете его указать.

По умолчанию базовым типом для `enum` с областью видимости является `int`:
```cpp
enum class Status; // Базовый тип - int
```
Если вас не устраивает значение по умолчанию, вы можете его перекрыть:
```cpp
enum class Status: std::uint32_t;
```
В любом случае компиляторы знают размер перечислителей в перечислении с областью видимости.
Чтобы указать базовый тип для перечисления без области видимости, вы делаете то же, что и для перечисления с областью видимости, и полученный результат может быть предварительно объявлен:
```cpp
enum Color: std::uint8_t;
```
Спецификация базового типа может быть укзаана и в определении `enum`:
```cpp
enum class Status: std::uint32_t { good = 0,
								   failed = 1,
								   incomplete = 100,
								   corrupt = 200,
								   interminate = 0xFFFFFFFF
};
```

Несмотря на все премущества перечислений с областью видимости, есть как минимум одна ситуация, в которой могуть быть полезны перечисления без области видимости, а именно - при обращении к полям в кортежах С++11 `std::tuple`. Предположим, например, что у нас есть кортеж, содержащий имя, адрес электронной почты и репутацию пользователя на сайте:
```cpp
using UserInfo = 
	std::tuple<std::string, // Имя
			   std::string, // Адрес
			   std::size_t> // Репутация
```
Хотя комментарии указывают, что представляет собой каждое поле кортежа, это, вероятно, не слишком полезно, когда вы сталкиваетесь с кодом наподобие следующего в отдельном исходном файле:
```cpp
UserInfo uInfo;                 // Объект с типом кортежа
...
auto val = std::get<1>(uInfo);  // Получение значения поля 1
```
Как программисту вам приходится отслеживать множество вещей. Вы действительно должны помнить, что поле 1 соответсвует адресу электронной почты пользователя? Я думаю, нет. Использование `enum` без области видимости для сопоставления имен полей с их номерами позволяет избежать необходимости перегружать память:
```cpp
enum UserInfoFields {uiName, uiEmail, uiReputation};

UserInfo uInfo;
...
auto val = std::get<uiEmail>(uInfo);
```
Все было бы гораздо сложнее без неявного преобразования значений из `UserInfoFields` в тип `std::size_t`, который является типом, требующимся для `std::get`. Код с использованием `enum class` был бы многословнее, поскольку вынужден применять `static_cast`.

Эта многословность может быть преодолена с помощью функции, которая принимает перечислитель и возвращает соответствующее значение типа `std::size_t`, но это немного сложнее. `std::get` является шаблоном, так что предоставляемое значение является **аргументом шаблона**, так что функция, преобразующая перечислитель в значение `std::size_t`, должна давать результат *во время компиляции*. Это означает, что нам нужна функция, являющаяся `constexpr`.

Фактически это должен быть `constexpr`- шаблон функции, поскольку он должен работать с любыми перечислениями. И если мы собираемся делать такое обобшение, то должны обобщить также и возвращаемый тип. Вместо того чтобы возвращать `std::size_t`, мы должны возвращать базовый тип перечисления. Он доступен с помощью свойства `std::underlying_type`. Наконец мы объявим его как `noexcept`, поскольку мы знаем, что он никогда не генерирует исключений. В результате мы получим шаблон функции `toUType`, который получает произвольный перечислитель и может возвращать значение как константу времени компиляции:
```cpp
template<typename E>
constexpr typename std::underlying_type<E>::type
	toUType(E enumerator) noexcept
{
	return
		static_cast<typename
			std::underlying_type<E>::type>(enumerator);
}
```
В С++14 `toUType` можно упросить заменой `typename std::underlying_type<E>::type` более изящным `std::underlying_type_t`:
```cpp
template<typename E>
constexpr std::underlying_type_t<E>
	toUType(E enumerator) noexcept
{
	return static_cast<std::underlying_type_t<E>>(enumerator);
}
```
Еще более изящный возвращаемы тип `auto` также корректен в С++14:
```cpp
template<typename E>
constexpr auto
	toUType(E enumerator) noexcept
{
	return static_cast<std::underlying_type_t<E>>(enumerator);
}
```
Независимо от того, как он написан, шаблон `toUType` позволяет нам обратиться к полю кортежа следующим образом:
```cpp
auto val = std::get<toUType(UserInfoFields::uiEmail)>(uInfo);
```
Это все же больше, чем достаточно написать при использовании перечисления без области видимости, но зато позволяет избежать загрязнения пространства имен и непреднамеренных преобразования перечислителей. Во многих случаях вы можете решить, что набор нескольких дополнительных символов является разумной ценой за возможность избежать ловушек перечислений, появление которых восходит ко времени, когда вершиной достижений в цифровых телекоммуникациях был модем со скоростью 2400 бод.

>[!note] Следует запомнить
>- Перечисления в стиле С++98 в настоящее время известны как перечисления без областей вилимости.
>- Перечислители перечислений с областями видимости видимы только внутри перечислений. Они преобразуются в другие типы только с помощью явных приведений.
>- Как перечисления с областями видимости, так и без таковых поддерживают указание базового типа. Базовым типом по умолчанию для перечисления с областью видимости является `int`. Перечисление без области видимости базового типа по умолчанию не имеет.
>- Перечисления с областями видимости могут быть предварительно объявлены. Перечисления без областей видимости могут быть предварительно объявлены только если их объявление указывает базовый тип.