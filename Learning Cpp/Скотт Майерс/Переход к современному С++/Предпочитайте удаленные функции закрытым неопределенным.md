Если вы предоставляете код другим разработчикам и хотите предотвратить вызов ими некоторой функции, обычно вы просто ее не объявляете. Нет объявления функции - нечего и вызывать. Но иногда С++ объявляет функции вместо вас, и если вы хотите предотвратить вызов таких функций клиентами вашего кода, придется постараться.

Эта ситуация возникает только для "специальных функций-членов", т.е. функций-членов, которые при необходимости С++ генерирует автоматически. В разделе [[Генерация специальных функций-членов]] эти функции рассматриваются более подробно, а пока что мы будем беспокоиться только о копирующем конструкторе и копирующем операторе присваивания.

Подход С++98 для предотвращения применения этих функций состоит в объявлении их как `private` без предоставления определений. Например, вблизи с основанием иерархии потоков ввода-вывода в стандартной библиотеке С++ находится шаблонный класс `basic_ios`. Все классы потоков наследуют (возможно, косвенно) этот класс. Копирование потоков ввода-вывода нежелательно, поскольку не совсем очевидно, что же должна делать такая операция. Объект `istream`, например, представляет поток входных значений, одни из которых могут уже быть считаны, а другие могут потенциально быть считаны позже. Если копировать такой поток, то должно ли это повлечь копирование всех считанных значений, а также значений, которые будут считаны в будущем? Простейший способ разобраться в таких вопросах - объявить их несуществующими. Именно это делает запрет на копирование потоков.

Чтобы сделать классы потоков некопируемыми, `basic_ios` в С++98 объявлен следующим образом:
```cpp
template <class charT, class traits = char_traits<charT> >
class basic_ios : public ios_base {
public:
	...
private:
	basic_ios(const basic_ios& );           // Не определен
	basic_ios& operator=(const basic_ios&); // Не определен
};
```
Объявление этих функций как `private` предотвращает их вызов клиентами. Умышленное отсутствие их определений означает, что если код, все еще имеющий к ним доступ (т.е. функции-члены или друзья класса), ими воспользуется, то компоновка (редактирование связей) будет неудачной из-за отсутствия определения функций.

В С++11 имеется лучший способ достичь по сути того же самого: воспользоваться конструкцией `= delete`, чтобы пометить копирующий конструктор и копирующее присваивание как *удаленные функции*. Вот так же часть `basic_ios` в С++11:
```cpp
template <class charT, class traits = char_traits<charT> >
class basic_ios : public ios_base {
public:
	...
	basic_ios(const basic_ios& ) = delete;
	basic_ios& operator=(const basic_ios&) = delete;
};
```
Отличие удаления этих функций от их объявления как `private` может показаться больше вопросом вкуса, чем чем-то иным, но на самом деле в это заложено больше. чем вы думаете. Удаленные функции не могут использоваться никоим образом, так что даже код функции-члена или функций, объявленных как `friend`, не будет компилироваться, если попытается копировать объекты `basic_ios`. Это существенное улучшение по сравнению с поведением С++98, где такое некорректное применение функций не диагностируется до компоновки.

По соглашению удаленные функции объявляются как `public`, а не `private`. Тому есть причина. Когда код клиента пытается использовать функцию-член, С++ проверяет доступность до проверки состояния удаленности. Когда клиентский код пытается использовать функцию, объявленную как `private`, некоторые компиляторы жалуются на то, что это закрытая функция, несмотря на то что доступность функции никак не влияет на возможность ее использования. Стоит принять это во внимание при пересмотре старого кода и замене не определенных функций-членов, объявленных как `private`, удаленными, поскольку объявление удаленных функций как `public` в общем случае приводит к более корректным сообщениям об ошибках.

Важным преимуществом удаленных функций является то, что удаленной может быть любая функция, в то время как быть `private` могут только функции-члены. Предположим, например, что у нас есть функция, не являющаяся членом, которая принимает целочисленное значение и сообщает, является ли оно "счастливым числом":
```cpp
bool isLucky(int number);
```
То, что C++ является наследником С, означает, что почти любой тип, который можно рассматривать как отчасти целочисленный, будет неявно преобразовываться в `int`, но некоторые компилируемые вызовы могут не иметь смысла:
```cpp
if (isLucky('a')) ...     // Является ли 'a' счастливым числом?
if (isLucky(true)) ...    // Является ли true счастливым числом?
if (isLucky(3.5)) ...     // Следует ли выполнить усечениие до
                          // 3 перед провекрой ?
```
Если счастливые числа действительно должны быть только целыми числами, хотелось бы предотвратить такие вызовы, как показано выше.
Один из способов достичь этого - создание удаленных перегрузок для типов, которые мы хотим отфильтровать:
```cpp
bool isLucky(int number);
bool isLucky(char)    = delete;
bool isLucky(bool)    = delete;
bool isLucky(double)  = delete;
```
Хотя удаленные функции использовать нельзя, они являются частью вашей программы. Как таковые они принимаются во внимание при разрешении перегрузки.

Еще один трюк, который могут выполнять удаленные функции (а функции-члены, объявленные как `private` - нет), заключается в предотвращении использования инстанцирования шаблонов, которые должны быть запрещены. Предположим, например, что нам нужен шаблон, который работает со встроенными указателями:
```cpp
template<typename T>
void processPointer(T* ptr);
```
В мире указателей есть два особых случая. Один из них - указатели `void*`, поскольку их нельзя разыменовывать, увеличивать или уменьшать и т.д. Второй - указатели `char*`, поскольку они обычно представляют указатели на С-строки, а не на отдельные символы. Эти особые случаи часто требуют особой обработки; будем считать, что в случае шаблона `processPointer` эта особая обработка заключается в том, чтобы отвергнуть вызовы с такими типами (т.е. должно быть невозможно вызвать `processPointer` c указателями типа `void*` или `char*`).
Это легко сделать. Достаточно удалить эти инстанцирования:
```cpp
template<>
void processPointer<void>(void*) = delete;

template<>
void processPointer<char>(char*) = delete;
```
Теперь, если вызов `processPointer` с указателями `void*` или `char*` является некорректным, вероятно, таковым же является и вызов с указателями `const void*` или `const char*`, так что эти инстанцирования обычно также следует удалить:
```cpp
template<>
void processPointer<const void>(const void*) = delete;

template<>
void processPointer<const char>(const char*) = delete;
```
И если вы действительно хотите быть последовательным, то вы также удалите перегрузки `const volatile void*` и `const volatile char*`, а затем приступите к работе над перегрузками для указателей на другие стандартные типы символов: `wchar_t`, `char16_t` и `char32_t`.

Интересно, что если у вас есть шаблон функции внутри класса и вы попытаетесь отключить некоторые инстанцирования, объявляя их `private` (в духе классического соглашения С++98), то у вас ничего не получится, потому что невозможно дать специализации шаблона функции-члена другой уровень доступа, отличный от доступа в главном шаблоне. Например, если `processPointer` представляет собой шаблон функции-члена в `Widget` и вы хотите отключить вызовы для указателей `void*`, то вот как будет выглядеть (не компилируемый) подход С++98:
```cpp
class Widget {
public:
	...
	template<typename T>
	void processPointer(T* ptr)
	{ ... }
private:
	template<>                         // Ошибка!
	void processPointer<void>(void*);
};
```
Проблема заключается в том, что специализации шаблона должны быть написаны в области видимости пространства имен, а не области видимости класса. Эта проблема не возникает для удаленных функций, поскольку они не нуждаются в другом уровне доступа. Они могут быть удалены за пределами класса (а следовательно, в области видимости пространства имен):
```cpp
class Widget {
public:
	...
	template<typename T>
	void processPointer(T* ptr)
	{ ... }
};

template<>      // Все еще public, но удаленная
void Widget::processPointer<void>(void*) = delete;
```
Истина заключается в том, что практика С++98 объявления функций `private` без их определения в действительности была попытка добиться того, для чего на самом деле созданы удаленные функции С++11. Будучи всего лишь имитацией, подход С++98 работает не так хорошо, как вещь, которую он имитирует. Он не работает вне классов, не всегда работает внутри классов, а когда работает, то может не работать до компоновки. Так что лучше придерживать удаленных функций.

>[!note] Следует запомнить
>- Предпочитайте удаленные функции закрытым функциям без определений.
>- Удаленной может быть любая функция, включая функции, не являющиеся членами, и инстанцирования шаблонов.