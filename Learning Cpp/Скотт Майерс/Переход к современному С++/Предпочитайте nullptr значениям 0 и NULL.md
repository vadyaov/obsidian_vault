Дело вот в чем: литерал 0 представляет собой `int`, а не указатель. Если С++ встретит 0 в контексте, где может использоваться только указатель, он интерпретирует 0 как нулевой указатель, но это - запасной выход. Фундаментальная стратегия С++ состоит в том, что 0 - это значения типа `int`, а не указатель.

С практической точки зрения то же самое относится и к `NULL`. В случае `NULL` имеется некоторая неопределенность в деталях, поскольку реализациям позволено придавать `NULL` целочисленный тип, отличный от `int` (например, `long`). Это не является распространенной практикой, но в действительности не имеет значения, поскольку вопрос не в точном типе `NULL`, а в том, что ни 0, ни `NULL` не имеют тип указателя.
В С++98 основным следствием этого факта было то, что перегрузка с использованием типов указателей и целочисленных типов могла привести к сюрпризам. Передача 0 или `NULL` таким перегрузкам никогда не приводила к вызову функции с указателем:
```cpp
void f(int);    // Три перегрузки функции int
void f(bool);
void f(void*);

f(0);           // Вызов f(int), не f(void*)
f(NULL);        // Может не компилироваться, но обычно
                // вызвает f(int) и никогда - f(void*)
```
Неопределенность в отношении поведения `f(NULL)` является отражением свободы, предоставленной реализациям в отношении типа `NULL`. Если `NULL` определен, например, как `0L`, то вызов является неоднозначным, поскольку преобразования `long` в `int`, `long` в `bool` и `0L` в `void*` рассматриваются как одинаково подходящие. Интересно, что этот вызов является противоречием между видимым смыслом исходного текста ("вызываем f с нулевым указателем NULL") и фактическим смыслом ("вызываем f с некоторой разновидностью целых чисел - не указателем"). Это противоречащее интуиции поведение приводит к рекомендации программистам на С++98 избегать перегрузки типов указателей и целочисленных типов. Эта рекомендация остается в силе и в С++11, поскольку некоторые разработчики продолжают применять 0 и NULL, несмотря на то что `nullptr` является лучшим выбором.

Преимущество `nullptr` заключается в том, что это значение не является значением целочисленного типа. Честно говоря, он не имеет и типа указателя, но его можно рассматривать как указатель *любого* типа. Фактическим типом `nullptr` является `std::nullptr_t`, ну, а тип `std::nullptr_t` циклически определяется как тип значения `nullptr...` Тип `std::nulllptr_t` неявно преобразуется во все типы обычных указателей, и именно это делает `nullptr` действующим как указатель всех типов.

Вызов перегруженной функции `f` с `nullptr` приводит к вызову перегрузки `void*` (т.е. перегрузки с указателем), поскольку `nullptr` нельзя рассматривать как что-то целочисленное:
```cpp
f(nullptr);   // вызов f(void*)
```
Использование `nullptr` вместо 0 или `NULL` позволяет избежать сюрпризов перегрузки, но это не единственное его преимущество. Оно позволяет также повысить ясность кода при применении
`auto`- переменных.

Особенно ярко сияет `nullptr`, когда на сцене появляются шаблоны. Предположим, что у вас есть несколько функций, которые должны вызываться только при блокировке соответствующего мьютекса. Каждая функция получает указатель определенного вида:
```cpp
int f1(std::shared_ptr<Widget> spw);   // Вызывается только при
double f2(std::unique_ptr<Widget> upw);// блокировке соответ-
bool f3(Widget* pw);                   // ствующего мьютекса
```
Вызывающий код с передачей нулевых указателей может выглядеть следующим образом:
```cpp
std::mutex f1m, f2m, f3m;    // Мьютексы для f1, f2, f3
using MuxGuard =             // C++11 typedef
	std::lock_guard<std::mutex>;

{
	MuxGuard g(f1m);          // Блокировка мьютекса для f1
	auto result = f1(0);      // Передача 0 функции f1
}                             // Разблокирование мьютекса
...
{
	MuxGuard g(f2m);          // Блокировка мьютекса для f2
	auto result = f2(NULL);   // Передача NULL функции f2
}                             // Разблокирование мьютекса
...
{
	MuxGuard g(f3m);           // Блокировка мьютекса для f3
	auto result = f3(nullptr); // Передача nullptr функции f3
}                              // Разблокирование мьютекса
```
То, что в первых двух вызовах не был передан `nullptr`, грустно; тем не менее код работает, а это чего-то да стоит. Однако повторяющиеся действия еще более грустны. Они просто беспокоят. Во избежание дублирования такого вида и предназначаются шаблоны, так что давайте превратим эти действия в шаблон.
```cpp
template<typename FuncType,
		 typename MuxType,
		 typename PtrType>
auto lockAndCall(FuncType func,
				 MuxType& mutex,
				 PtrType ptr) -> decltype(func(ptr))
{
	using MuxGuard = std::lock_guard<MuxType>;

	MuxGuard g(mutex);
	return func(ptr);
}
```
Если возвращаемый тип этой функции (`auto...->decltype(func(ptr)))` заставляет вас чесать затылок, обратитесь к разделу [[Знакомство с decltype]]. В С++14 возвращаемый тип можно свести к простому `decltype(auto)`:
```cpp
template<typename FuncType,
		 typename MuxType,
		 typename PtrType>
decltype(auto) lockAndCall(FuncType func,
				 MuxType& mutex,
				 PtrType ptr)
{
	using MuxGuard = std::lock_guard<MuxType>;

	MuxGuard g(mutex);
	return func(ptr);
}
```
Для данного шаблона `lockAndCall` вызывающий код может иметь следующий вид:
```cpp
auto res1 = lockAndCall(f1, f1m, 0);          // Ошибка!
auto res2 = lockAndCall(f2, f2m, NULL);       // Ошибка!
auto res2 = lockAndCall(f3, f3m, nullptr);    // OK
```
Такой код можно написать, но, как показывают комментарии, в двух случаях из трех этот код компилироваться не будет. В первом вызове проблема в том, что когда 0 передается в `lockAndCall`, происходит вывод соответствующего типа шаблона. Типом 0 является `int`, как и типа параметра `ptr` в инстанцировании данного вызова `lockAndCall`. 

К сожалению, это означает, что в вызов `func` в `lockAndCall` передается `int`, а этот тип несовместим с параметром `std::shared_ptr<Widget>`, ожидаемым функцией `f1`. Значение 0, переданное в вызове `lockAndCall`, призвано представлять нулевой указатель, но на самом деле передается заурядный `int`. Попытка передать этот `int` функции `f1` как `std::shared_ptr<Widget>` представляет собой ошибку типа. Вызов `lockAndCall` c 0 оказывается неудачным, поскольку в шаблоне функции, которая требует аргумент типа `std::shared_ptr<Widget>`, передается значение `int`.

Анализ вызова с переданным `NULL` по сути такой же. Когда в функцию `lockAndCall` передается `NULL`, для параметра `ptr` выводится целочисленный тип, и происходит ошибка, когда целочисленный тип передается функции `f2`, которая ожидает аргумент типа `std::unique_ptr<Widget>`.

В противоположность первым двум вызовам вызов с `nullptr` никакими неприятностями не отличается. Когда функции `lockAndCall` передается `nullptr`, выведенным типом `ptr` является `std::nullptr_t`. При передаче `ptr` в функцию `f3` выполняется неявное преобразование `std::nullptr_t` в `Widget*`, поскольку `std::nullptr_t` неявно преобразуется во все типы указателей.

Тот факт, что вывод типа шаблона приводит к "неверным" типам для 0 и NULL (т.е. к их истинным типам, а не к представлению с их использованием нулевых указателей), является наиболее убедительной причиной для использования `nullptr` вместо 0 или NULL, когда вы хотите передать нулевой указатель. При применении `nullptr` шаблоны не представляют собой никаких особых проблем. Вместе с тем фактом, что `nullptr` не приводят к неприятностям при разрешении перегрузки, которым подвержены 0 и NULL, все это приводит к однозначному выводу - если вам нужен нулевой указатель - используйте `nullptr`, но не 0 и не NULL.

>[!note] Следует запомнить
>- Предпочитайте применение `nullptr` использованию 0 или NULL
>- Избегайте перегрузок с использованием целочисленных типов и типов указателей.