Если мы работаем в области математики, нам может пригодиться класс, представляющий полиномы. В этом классе было бы неплохо иметь функцию для вычисления корней полинома, т.е. значений, при которых значение полинома равно нулю. Такая функция не должна модифицировать полином, так что ее естественно объявить как `const`:
```cpp
class Polynomial {
public:
	// Структура данных, хранящая значения, где полином равен нулю
	using RootsType = std::vector<double>;
	...
	RootsType roots() const;
};
```
Вычисление корней -- трудная дорогостоящая операция, так что мы не хотим их вычислять до того, как они реально потребуются. Но если они нам требуются, то, определенно, требуются не один раз. Поэтому мы будем кэшировать корни полиномов, если нам приходится их вычислять, и реализуем `roots` так, чтобы функция возвращала кешированное значение. Вот как выглядит такой подход:
```cpp
class Polynomial {
public:
	using RootsType = std::vector<double>;

	RootsType roots() const {
		// Если кеш некорректен, вычисляем
		// корни и сохраняем их в rootVals
		if (!rootsAreValid) {
			// calculate roots (expensive operation)
			rootsAreValid = true;
		}
		return rootVals;
	}
private:
	mutable bool rootsAreValid{ false; }
	mutable RootsType rootVals{ };
};
```
Концептуально `roots` не изменяет объект `Polynomial`, с которым работает, но в качестве части кеширующих действий может потребоваться изменение `rootVals` и `rootsAreValid`. Это классический случай использования `mutable`, и именно эти данные-члены объявлена с данным модификатором.

Представим теперь, что два потока одновременно вызывают `roots` для объекта `Polynomial`:
```cpp
Polynomial p;
...
/*----- Поток 1 -----*/            /* ----- Поток 2 ----- */
auto rootsOfP = p.roots();         auto valsGivingZero = p.roots();
```
Этот клиентский код совершенно разумен. Функция `roots` является константной функцией-членом, и это означает, что она представляет операцию чтения. Выполнение операций чтения несколькими потоками одновременно без синхронизации вполне безопасно. Как минимум предполагается, что это так. В данном случае это не так, поскольку в функции `roots` один или оба эти потока могут попытаться изменить члены-данные `rootsAreValid` и `rootVals`. Это означает, что данный код может одновременно читать и записывать одни и те же ячейки памяти без синхронизации, а это -- определение гонки данных. Такой код имеет неопределенное поведение.

Проблема заключается в том, что функция `roots` объявлена как `const`, но не является безопасной с точки зрения потоков. Объявление `const` является корректным (вычисление корней полинома не изменяет сам полином), так что коррекция нужна для повышения безопасности потоков.

Простейший способ решения проблемы обычно один - применение `mutex`:
```cpp
class Polynomial {
public:
	using RootsType = std::vector<double>;

	RootsType roots() const {
		// Блокировка мьютекса
		std::lock_guard<std::mutex> g(m);
		// Если кеш некорректен, вычисляем
		// корни и сохраняем их в rootVals
		if (!rootsAreValid) {
			...
			rootsAreValid = true;
		}
		return rootVals;
	}
private:
	mutable std::mutex m;
	mutable bool rootsAreValid{ false; }
	mutable RootsType rootVals{ };
};
```
Мьютекс `std::mutex` `m` объявлен как `mutable`, поскольку его блокировка и разблокировка являются неконстантными функциями, а в противном случае в константной функции-члене `roots` мьютекс `m` рассматривается как константный объект.

Следует отметить, что поскольку `std::mutex` не может быть ни скопирован, ни перемещен, побочным эффектом добавления `m` к `Polynomial` является то, что `Polynomial` теряет возможность копирования и перемещения.

В некоторых ситуациях мьютекс является излишеством. Например, если все, что вы делаете, -- это подсчитываете, сколько раз вызывается функция-член, то часто более дешевым средством является счетчик `std::atomic` (т.е. счетчик, для которого гарантируется атомарность операций).
> Действительно ли это более дешевое средство, зависит от аппаратного обеспечения и реализации мьютексов в вашей стандартной библиотеке.

Вот как можно использовать `std::atomic` для подсчета вызовов:
```cpp
class Point {
public:
	...
	double distanceFromOrigin() const noexcept {
		++callCount;  // атомарный инкремент
		return std::hypot(x, y);
	}
private:
	mutable std::atomic<unsigned> callCount {0};
	double x, y;
};
```
Как и `std::mutex`, `std::atomic` невозможно копировать и перемещать, так что наличие `callCount` в `Point` означает, что `Point` также невозможно и перемещать.

Поскольку операции над переменными `std::atomic` зачастую менее дорогостоящи, чем захват и освобождение мьютекса, вы можете соблазниться использовать `std::atomic` больше, чем следует. Например, в классе, кеширующем дорогостоящее для вычисления значение `int`, вы можете попытаться использовать вместо мьютекса пару переменных `std::atomic`:
```cpp
class Widget {
pulbic:
	...
	int magicValue() const {
		if (cacheValid) return cachedValue;
		else {
			auto val1 = expensiveComputation1();
			auto val2 = expensiveComputation2();
			cachedValue = val1 + val2;  // Часть 1
			cachevalid = true;          // Часть 2
			return cachedValue;
		}
	}
private:
	mutable std::atomic<bool> cacheValid {false};
	mutable std::atomic<int> cachedValue;
};
```
Этот способ работает, но иногда выполняет существенно большую работу, чем требуется. Рассмотрим такой сценарий.
- Поток вызывает `Widget::magicValue`, видит, что `cacheValid` равно `false`, выполняет два дорогостоящих вычисления и присваивает их сумму переменной `cachedValue`.
- В этот момент второй поток вызывает `Widget::magicValue`, также видит, что значение `cachedValid` равно `false`, а потому выполняет те же дорогостоящие вычисления, что и только что завершивший их первый поток. (Этот "второй поток" на самом деле может быть *несколькими* другими потоками)

Чтобы справиться с этой проблемой, можно пересмотреть порядок присваиваний значений переменным `cachedValue` и `cacheValid`, но вы вскоре поймете, что:
1. Вычислять `val1` и `val2` перед тем, как `cacheValid` устанавливается равным `true`, по-прежнему могут несколько потоков, тем самым провалив цель нашего упражнения;
2. На самом деле все может быть еще хуже:
```cpp
class Widget {
pulbic:
	...
	int magicValue() const {
		if (cacheValid) return cachedValue;
		else {
			auto val1 = expensiveComputation1();
			auto val2 = expensiveComputation2();
			cachevalid = true;
			return cachedValue = val1 + val2;
		}
	}
private:
	mutable std::atomic<bool> cacheValid {false};
	mutable std::atomic<int> cachedValue;
};
```
Представим, что значение `cacheValid` равно `false`. Тогда возможно следующее.
- Один поток вызывает `Widget::magicValue` и выполняет код до точки, где переменная `cacheValid` устанавливается равной `true`.
- В этот момент второй поток вызывает `Widget::magicValue` и проверяет значение `cacheValid`. Увидев, что оно равно `true`, поток возвращает `cachedValue`, несмотря на то, что первый поток еще не выполнил присваивание этой переменной. Таким образом, возвращенное значение окажется некорректным.

Это неплохой урок. Для единственной переменной или ячейки памяти, требующей синхронизации, применение `std::atomic` является адекватным решением, но как только у вас имеется две и более переменных или ячеек памяти, которым надо оперировать как единым целым, вы должны использовать мьютекс. Для `Widget::magicValue` это выглядит следующим образом:
```cpp
class Widget {
pulbic:
	...
	int magicValue() const {
		std::lock_guard<std::mutex> guard(m);
		if (cacheValid) return cachedValue;
		else {
			auto val1 = expensiveComputation1();
			auto val2 = expensiveComputation2();
			cachedValue = val1 + val2;
			cachevalid = true;
			return cachedValue;
		}
	}
private:
	mutable std::mutex m;
	mutable bool cacheValid {false};
	mutable int cachedValue;
};
```
Сейчас данный раздел основывается на предположении, что несколько потоков могут одновременно выполнять константную функцию-член объекта. Если вы пишете константную функцию-член там, где это не так - т.е. там, где вы можете *гарантировать*, что эта функция-член объекта никогда не будет выполняться более чем одним потоком, -- безопасность с точки зрения потоков является несущественной.
Например, совершенно неважно, являются ли безопасными с точки зрения потоков функции-члены классов, разработанные исключительно для однопоточного применения. В таких случаях вы можете избежать расходов, связанных с мьютексами и `std::atomic`, а также побочного эффекта, заключающегося в том, что содержащие их классы становятся некопируемыми и неперемещаемыми. Однако такие сценарии, в которых нет потоков, становятся все более редкими и, вероятно, дальше будут становиться только все более редкими. Безопаснее считать, что константные функции-члены будут участвовать в параллельных вычислениях, и именно поэтому следует гарантировать безопасность таких функций с точки зрения потоков.
>[!note] Следует запомнить
>- Делайте константные функции-члены безопасными с точки зрения потоков, если только вы не можете быть уверены, что они *гарантированно* не будут использоваться в контексте параллельных вычислений.
>- Использование переменных `std::atomic` может обеспечить более высокую по сравнению с мьютексами производительность, но они годятся только для работы с единственной переменной или ячейкой памяти.