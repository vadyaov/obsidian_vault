Итераторы `const_iterator` представляют собой STL-эквивалент указателя на `const`. Они указывают на значения, которые не могут быть изменены. Стандартная практика применения `const` там, где это только возможно, требует применения `const_iterator` везде, где нужен итератор, но не требуется изменять то, на что этот итератор указывает.

Это верно как для С++98, так и для С++11, но в С++98 поддержка `const_iterator` носит половинчатый характер. Такие итераторы не так легко создавать, а если у вас уже имеется такой итератор, его использование весьма ограничено. Предположим, например, что вы хотите выполнить в `std::vector<int>` поиск первого встречающегося значения, а затем вставить в это место другое значение. Если в векторе нет нужного значения, вставка производится в конец вектора.
При использовании итераторов `interator` в С++98 сделать описанное просто:
```cpp
std::vector<int> values;

std::vector<int>::iterator it =
    std::find(values.begin(), values.end(), 1983);
values.insert(it, 1998);
```
Но итератор - в данном случае не совсем верный выбор, поскольку этот код не изменяет объект, на который указывает `interator`. Переделка кода для использования `const_iterator` должна быть тривиальной задачей... но не в С++98. Вот один из подходов, концептуально надежный, но все еще не совсем корректный:
```cpp
typedef std::vector<int>::iterator IterT;
typedef std::vector<int>::const_iterator ConstIterT;

std::vector<int> values;

ConstIterT ci =
    std::find(static_cast<ConstIterT>(values.begin()),
		      static_cast<ConstIterT>(values.end()),
		      1983);

values.insert(static_cast<IterT>(ci), 1998); // Может не компил-ся
```
Приведения в вызове `std::find` присутствуют потому, что `values` является неконстантным контейнером, а в С++98 нет простого способа получить константный итератор из неконстантного контейнера.  Приведения не являются строго необходимыми, так как можно получить `const_iterator` другими способами (например, вы можете связать `values` с переменной, являющейся ссылкой на константный объект, а затем использовать ее в своем коде вместо `values`), но к какому бы способу вы ни прибегали, процесс получения `const_iterator`, указывающего на элементы неконстантного контейнера, включает определенное количество "кривизны".

После того как вы получаете `const_iterator`, ситуация ничуть не улучшается, поскольку в С++98 местоположения для вставки (и удаления) могут указывать только неконстантные итераторы `iterator`. Итераторы `const_iterator` для этого неприменимы. Вот почему в приведенном выше коде я выполняю приведение `const_iterator` (который я с таким трудом получил из `std::find`) в `iterator`: передача `const_interator` в функцию `insert` не будет компилироваться.

Честно говоря, показанный код может не скомпилироваться, поскольку не существует переносимого преобразования `const_iterator` в `interator`, даже с помощью `static_cast`. Может не сработать даже семантическая кувалда `reinterpret_cast`. Есть несколько переносимых способов сгенерировать `interator`, который указывает на то же, на что и `const_iterator`, но они не очевидны, не универсальны и не стоят того, чтобы рассматривать их. Кроме того, я надеюсь, что теперь понятна моя позиция: `const_iterator` причиняли так много неприятностей в С++98, что редко стоили того, чтобы о них беспокоиться и их использовать. По большому счету программисты всегда использовали `const` не где это только возможно, а только там, где это практично, а в С++98 `const_iterator` особо практичным не является.

Все изменилось с появлением С++11. Теперь `const_iterator` легко получить и легко использовать. Функции члены контейнера `cbegin` и `cend` возвращают `const_iterator` даже для неконстантных контейнеров, а функции-члены STL, которые применяют итераторы для указания позиций (например, `insert` и `erase`), в действительности используют итераторы `const_iterator`. Теперь все воистину тривиально:
```cpp
std::vector<int> values;             // Как и ранее
...
auto it =
    std::find(values.cbegin(), values.cend(), 1983);
values.insert(it, 1998);
```
Теперь код, использующий `const_iterator`, стал действительно практичным!

Почти единственной ситуацией, в которой поддержка С++11 для `const_interator` оказывается недостаточной, является ситуация, когда вы хотите написать максимально обобщенный библиотечный код. Такой код принимает во внимание то, что некоторые контейнеры и контейнерообразные структуры данных предоставляют функции `begin` и `end` (а также `cbegin`, `cend`, `rbegin` и т.д.) как функции, не являющиеся членами. Это происходит, например, в случае встроенных массивов или при использовании некоторых библиотек сторонних производителей с интерфейсами, состоящими только из свободных функций. Максимально обобщенный код использует функции, не являющиеся членами, а не предполагает наличие функций-членов.

Например, мы можем обобщить код, с которым только что работали, в шаблон `findAndInsert` следующим образом:
```cpp
template<typename C, typename V>
void findAndInsert(C& container,         // В container находит
					const V& targetVal,  // первое значение
					const V& insertVal)  // targetVal, затем
{                                        // вставляет insertVal
	using std::cbegin;
	using std::cend;

	auto it = std::find(cbegin(container), // Не член cbegin
					    cend(container),   // Не член cend
					    targetVal);

	container.insert(it, insertVal);
}
```
Суть этого раздела заключается в том, чтобы призвать вас использовать `const_iterator` везде, где возможно. Фундаментальный мотив для этого - применение `const` всегда, когда это имеет смысл.

>[!note] Следует запомнить
>- Предпочитайте использовать `const_iterator` вместо `iterator` там, где это можно.
>- В максимально обобщенном коде предпочтительно использовать версии функций `begin`, `end`, `rbegin` и прочих, не являющихся членами.