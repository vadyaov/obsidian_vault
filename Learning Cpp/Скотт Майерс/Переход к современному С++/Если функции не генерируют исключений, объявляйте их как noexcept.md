В С++11 безусловный модификатор `noexcept` применяется к функциям, которые гарантированно не могут генерировать исключения.

Должна ли функция быть объявлена таким образом - вопрос проектирования интерфейса. Поведение генерирующих исключения функций представляет большой интерес для клиентов. Вызывающий код может запросить статус `noexcept` функции, и результат этого запроса может повлиять на безопасность в смысле исключений или эффективность вызывающего кода. Таким образом, является ли функция объявленной как `noexcept`, представляет собой столь же важную информацию, как и является ли функция-член объявленной как `const`. Отсутствие объявления функции как `noexcept`, когда вы точно знаете, что она не в состоянии генерировать исключения, - не более чем просто плохая спецификация интерфейса.

Но есть и дополнительный стимул для применения `noexcept` к функциям, которые не генерируют исключений: это позволяет компиляторам генерировать лучший объектный код. Чтобы понять, почему это так, рассмотрим разницу между способами, которыми С++98 и С++11 сообщают о том, что функция не может генерировать исключения. Пусть имеется функция `f`. которая обещает вызывающему коду, что то никогда не получит исключения. Вот как выглядят два способа это выразить:
```cpp
int f(int x) throw();   // f не генерирует исключений: С++98
int f(int x) noexcept;  // f не генерирует исключений: С++11
```
Если во время выполнения некоторое исключение покинет `f`, тем самым будет нарушена спецификация исключений `f`. При спецификации исключений С++98 стек вызовов сворачивается до вызывающего `f` кода, и после некоторых действий, не имеющих значения для данного рассмотрения, выполнение программы прекращается.
>[!info]
>*stack unwinding* обычно переводят как "разворачивание стека" или "раскрутка стека", однако такой перевод не просто затемняет существо дела, но просто противоположен ему.
>
>При срабатывании исключения начинается процесс поиска в стеке секции ("кадра стека", stack frame), для которой задан перехват случившегося исключения. В тексте исходной программы такой секции соответствует try-блок с catch-обработчиком, в котором задано имя случившегося исключения. И в процессе этого поиска все секции стека, для которых такой перехват не задан, из стека **удаляются**.
>
>Говорят еще, что производится поиск секции по всей динамической цепочке вызовов. Тем самым стек в целом сокращается, **сворачивается**.
>
>Таким образом, самый адекватный вариант перевода - **сворачивание стека**. Поэтому принято решение переводить *stack unwinding* как сворачивание стека.

При спецификации исключений С++11 поведение времени выполнения несколько иное: стек только, возможно, сворачивается перед завершением выполнения программы.

Разница между сворачиванием стека и *возможным* сворачиванием оказывает на удивление большое влияние на генерацию кода. В случае функции, объявленной как `noexcept`, оптимизаторам не надо ни поддерживать стек в сворачиваемом состоянии, ни гарантировать, что объекты в такой функции будут уничтожены в порядке, обратном созданию, если вдруг такую функцию покинет исключение. Функции со спецификацией `throw()` не имеют такой гибкости оптимизации, как и функции без спецификаций вообще. Ситуацию можно резюмировать следующим образом:
```cpp
RetType function(params) noexcept; // Наиболее оптимизируема
RetType function(params) throw();  // Менее оптимизирована
RetType function(params);          // Менее оптимизирована
```
Этого одного достаточно для того, чтобы объявлять функции, о которых точно известно, что они не генерируют исключений, как `noexcept`.

Для некоторых функций все оказывается еще более интересным. Выдающимся примером являются операции перемещения. Предположим, что у вас имеется код С++98, использующий `std::vector<Widget>`. Объекты типа `Widget` время от времени добавляются в `std::vector` с помощью функции `push_back`:
```cpp
std::vector<Widget> vw;
...
Widget w;
...
vw.push_back(w);
```
Предположим, что этот код отлично работает, и нет никакой необходимости изменять его для С++11. Однако вы хотите воспользоваться тем фактом, что семантика перемещения С++11 может улучшить производительность старого кода при участии типов, допускающих перемещающие операции. Вы уверены, кто класс `Widget` такие операции имеет - либо потому, что вы написали их самостоятельно, либо потому, что вы убедились в осуществлении условий для их автоматической генерации.

Когда в `std::vector` добавляется новый элемент, может оказаться, что в `std::vector` для него не хватает места, т.е. что размер `std::vector` равен его емкости. Когда такое случается, `std::vector` выделяет новый, больший по размеру блок памяти для хранения своих элементов и переносит элементы из старого блока в новый.
В С++98 перенос осуществляется с помощью копирования каждого элемента из старой памяти в новую с последующим удалением объекта в старой памяти. Этот подход позволяет `push_back` обеспечить строгую гарантию безопасности исключений: если исключение будет сгенерировано в процессе копирования элементов, то состояние `std::vector` останется неизменным, поскольку ни один элемент в старом блоке памяти не будет удален, пока все элементы не будут успешно скопированы в новое место в памяти.

В С++11 естественной оптимизацией была бы замена копирования элементов `std::vector` перемещениями. К сожалению, это ведет к риску нарушения строгой гарантии `push_back`. Если `n` элементов перемещены из старого блока памяти в новый и при перемещении `n+1`-го элемента генерируется исключение, операция `push_back` не может быть завершена. Но при этом исходный `std::vector` находится в измененном состоянии: `n` его элементов уже перемещены. Восстановление их исходных состояний может оказаться невозможным, поскольку попытка перемещения каждого объекта обратно в исходное местоположение в памяти также может привести к генерации исключения.

Это серьезная проблема, поскольку поведение старого кода может зависеть от строгой гарантии безопасности функции `push_back`. Следовательно, реализации С++11 не могут молча заменить операции копирования внутри `push_back` операциями перемещения, если только точно не известно, что операции перемещения не генерируют исключений. В таком случае замена копирований перемещениями должна быть безопасной, и единственным побочным эффектом этой замены будет повышение быстродействия.

Функция `std::vector::push_back` использует преимущество этой стратегии ("перемести, если сможешь, но копируй, если должен"), и это не единственная функция стандартной библиотеки, поступающая таким образом. Другие функции, обеспечивающие строгую гарантию безопасности исключений в С++98 (например, `std::vector::reserve`, `std::deque::insert` и др.), ведут себя точно так же. Все эти функции заменяют вызовы копирующих операций в С++98 вызовами перемещающих операций в С++11, только если известно, что перемещающие операции не генерируют исключений. Но как функция может узнать, генерирует ли исключения операция перемещения? Ответ очевиден: она должна проверить, объявлена ли операция как `noexcept`.
>[!info]
>Проверка обычно выполняется окольным путем. Функции наподобие `std::vector::push_back` вызывают шаблон `std::move_if_noexcept`, вариацию шаблона `std::move`, который условно выполняет приведение к rvalue, в зависимости от того, объявлен ли перемещающий конструктор как `noexcept`. В свою очередь, `std::move_if_noexcept` консультируется с `std::is_nothrow_move_constructible`, а значение этого свойства типа устанавливается компиляторами в зависимости от того, объявлен ли перемещающий конструктор как `noexcept`.

Функции `swap` являются еще одним случаем, когда модификатор `noexcept` особенно желателен. Функция `swap` является ключевым компонентом множества реализаций алгоритмов STL и обычно использует операторы копирующего присваивания. Ее широкое применение делает оптимизацию на основе `noexcept` особенно важной. Интересно, что то, является ли функция `swap` в стандартной библиотеке `noexcept`, иногда зависит от того, являются ли таковыми функции `swap`, определенные пользователем. Например, объявления `swap` в стандартной библиотеке для массивов и `std::pair` имеют следующий вид:
```cpp
template <class T, size_t N>
void swap(T (&a)[N], T (&b)[N]) noexcept (noexcept(swap(*a, *b)));

template <class T1, class T2>
struct pair {
	...
	void swap(pair& p) noexcept(noexcept(swap(first, p.first)) &&
								noexcept(swap(second, p.second)));
	...
};
```
Эти функции являются условно `noexcept`: являются ли они `noexcept`-функциями, зависит от того, являются ли таковыми инструкции в конструкции `noexcept`. Для двух заданных массивов `Widget`, например, их обмен с помощью функции `swap` будет считаться `noexcept` только в том случае, если таковыми будут операции обмена отдельных элементов; т.е. если функция `swap` для `Widget` объявлена как `noexcept`. Это, в свою очередь, определяет, будут ли таковыми другие операции обмена, такие как `swap` для массива массивов `Widget`. Аналогично, является ли операция `swap` двух объектов `std::pair`, содержащих `Widget`, не генерирующей исключений, зависит от того, является ли таковой операция `swap` для `Widget`. Тот факт, что обмен высокоуровневых структур данных в общем случае может быть `noexcept`, только если таковым является обмен их более низкоуровневых составляющих, должен мотивировать вас объявлять функции `swap` как `noexcept` везде, где только это возможно.

Следует отметить, что оптимизация важна, но корректность важнее. В начале этого раздела я отмечал, что noexcept является частью интерфейса функции, так что вы должны объявлять функцию как noexcept, только если вы готовы обеспечивать это свойство в течение длительного срока.
Если вы объявите функцию как noexcept, а позже измените ваше решение, то ваши перспективы окажутся невеселыми. Удаление noexcept из объявления функции (т.е. изменение ее интерфейса) ведет к риску нарушения клиентского кода. Можно также изменить реализацию так, что генерация исключения будет возможна, не меняя при этом (теперь уже некорректную) спецификацию исключений. В этом случае, если исключение попытается покинуть вашу функцию, программа завершит работу. Вы можете также подчиниться существующей реализации, забыв о своем желании ее изменить. Ни один из перечисленных вариантов привлекательным не выглядит.

Большинство функций *нейтральны по отношению к исключениям*. Такие функции сами по себе исключений не генерируют, но это могут делать функции, вызываемые ими. Когда такое происходит, нейтральная функция позволяет сгенерированному исключению пройти дальше, к обработчику, находящемуся выше по цепочке вызовов. Нейтральные по отношению к исключениям функции никогда не являются `noexcept`, поскольку их могут покидать такие "проходящие исключения". Поэтому большинство функций совершенно корректно не используют `noexcept`.

Некоторые функции, однако, имеют естественные реализации, которые не генерируют никаких исключений, а еще некоторое их количество (в основном операции перемещения и обмена), будучи `noexcept`, могут дать столь значительный выигрыш, что их стоит реализовывать как `noexcept`, насколько это возможно. Когда вы можете уверенно сказать, что за пределы функции не должно выйти ни одно исключение, вы, определенно, должны объявить ее как `noexcept`.

Некоторые функции имеют *естественную* реализацию `noexcept`. Изменение реализации функции только для того, чтобы объявить ее как `noexcept` - это хвост, виляющий собакой. Это телега перед лошадью. Это неумение увидеть лес за деревьями. Если простая реализация функции может приводить к исключениям (например, путем вызова функции, которая может сгенерировать исключение), то попытка скрыть это исключение от вызывающего кода (например, перехватывая все исключения и заменяя их кодами состояния или специальными возвращаемыми значениями) усложнит не только реализацию вашей функции, но обычно и код в точке вызова. Например, вызывающая функция, как может оказаться, должна проверять код состояния или наличие специальных возвращаемых значений. Стоимость времени выполнения таких усложнений (например, дополнительных ветвлений, вызовов функций, которые будут влиять на кеши команд, и т.п.) легко может превысить ускорение, которое вы надеялись получить благодаря `noexcept`; кроме того, такой исходный код труднее понимать и поддерживать. Ничего хорошего из этого не получается.

Для некоторых функций отсутствие исключений настолько важно, что они являются `noexcept` по умолчанию. В С++98 является плохим стилем разрешать генерировать исключения функциям освобождения память (т.е. операторам `delete` и `delete[]`) и деструкторам, а в С++11 это правило стиля стало правилом языка. По умолчанию все функции освобождения памяти и все деструкторы - как пользовательские, так и генерируемые компиляторами - неявно являются `noexcept`. Поэтому необходимости явно объявлять их таковыми нет. Единственная ситуация, когда деструктор не является неявно объявленным как `noexcept`, - это когда член-данные класса (включая унаследованные члены и содержащиеся внутри других членов-данных) имеет тип, который явно указывает, что его деструктор может генерировать исключения (например, объявленный как `noexcept (false)`). Такие деструкторы являются редкостью. Их нет в стандартной библиотеке, и если деструктор объекта, используемого стандартной библиотекой, генерирует исключение, поведение программы является неопределенным.

Стоит отметить, что некоторые проектировщики библиотечных интерфейсов различают функции с *широкими контрактами* от функций с *узкими контрактами*. Функция с широким контрактом не имеет предусловий. Такая функция может быть вызвана независимо от состояния программы и не накладывает никаких ограничений на аргументы, передаваемые ей вызывающим кодом.
> "Независимо от состояния программы" и "без ограничений" не узаконивает программы, поведение которых уже является неопределенным. Например, `std::vector::size` имеет широкий контракт, но это не означает, что данная функция должна разумно себя вести при применении к произвольному блоку памяти, приведенному к типу `std::vector`. Результат приведения не определен, поэтому нет никаких гарантий, касающихся поведения программы, содержащей такое приведение.

Функции без широких контрактов имеют узкие контракты. Если предусловия для таких функций нарушены, их результаты являются неопределенными.

Если вы пишете функцию с широким контрактом и знаете, что ее не покинут никакие исключения, легко следовать совету из данного раздела и объявить ее как `noexcept`. Для функций с узкими контрактами ситуация сложнее. Предположим, например, что вы пишете функцию `f`, принимающую параметр `std::string`, и пусть естественная реализация `f` никогда не генерирует исключений. Это предполагает, что функция `f` должна быть объявлена как `noexcept`.

Предположим теперь, что `f` имеет предусловие: длина ее строкового параметра `std::string` не должна превышать 32 символа. Если `f` вызывается со строкой, длина которой больше 32 символов, поведение будет неопределенным, поскольку нарушение предусловия *по определению* приводит к неопределенному поведению. Функция `f` не обязана проверять это предусловие, так как функции могут считать свои предусловия выполненными. (За обеспечение выполнения таких предположений отвечает вызывающий код) Тогда даже при наличии предусловия объявление `f` как `noexcept` выглядит целесообразным:
```cpp
void f(const std::string& s) noexcept;  // Предусловие:
                                        // s.length() <= 32
```
Но предположим, что разработчик `f` решил проверять нарушение предусловия. Такая проверка не обязательна, но она и не запрещена; более того, проверка предусловия может быть полезной, например, в процессе системного тестирования. Отладка сгенерированного исключения в общем случае проще, чем попытки отследить причину неопределенного поведения. Но как следует сообщать о нарушении предусловий, чтобы проверки (или клиентский обработчик ошибок) могли его обнаружить? Простейший подход - генерация исключения "предусловие нарушено", но если `f` объявлена как `noexcept`, это может быть невозможным; генерация исключения приведет к завершению программы. По этой причине разработчики библиотек, различающие широкие и узкие контракты, в общем случае резервируют `noexcept` для функций с широкими контрактами.

В заключение рассмотрим следующий корректный код:
```cpp
void setup();    // Функции, определенные в другом месте
void cleanup();

void doWork() noexcept
{
	setup();     // Настройка для выполнения некоторой работы
	...          // Выполнение работы
	cleanup();   // Очистка после выполнения работы
}
```
Здесь функция `doWork` объявлена как `noexcept`, несмотря на то, что она вызывает функции `setup` и `cleanup` без такого модификатора. Это кажется противоречием, но ведь может быть так, что функции `setup` и `cleanup` документированы как не генерирующие исключений, пусть при этом они и не объявлены как `noexcept`. Для такого их объявления могут иметься некоторые веские причины. Например, они могут быть частью библиотеки, написанной на С. (Даже у функций стандартной библиотеки С, перемещенных в пространство имен `std`, отсутствуют спецификации исключений; например, `std::strlen` не объявлена как `noexcept`) Они также могут быть частью стандартной библиотеки С++98, в которой решено не использовать спецификации исключений С++98 и которая еще не пересмотрена на предмет использования возможностей С++11.

Поскольку для функций, объявленных как `noexcept`, имеются законные основания полагаться на код, не имеющий гарантии `noexcept`, C++ допускает существование такого кода, и компиляторы в общем случае не выдают при этом никаких предупреждений о нем.

>[!note] Следует запомнить
>- `noexcept` является частью интерфейса функции, а это означает, что вызывающий код может зависеть от наличия данного модификатора.
>- Функции, объявленные как `noexcept`, предоставляют большие возможности оптимизации, чем функции без такой спецификации.
>- Спецификация `noexcept` имеет особое значение для операций перемещения, обмена, функций освобождения памяти и деструкторов.
>- Большинство функций нейтральны по отношению к исключениям, а не являются `noexcept`-функциями.