В официальной терминологии С++ *специальные функции-члены* -- это те функции-члены, которые С++ готов генерировать сам. С++98 включает четыре такие функции: конструктор по умолчанию, деструктор, копирующий конструктор и оператор копирующего присваивания. Эти функции создаются, только если они необходимы, т.е. если некоторый код использует их без их явного объявления в классе. Конструктор по умолчанию генерируется только в том случае, если в классе не объявлен ни один конструктор. (Это предотвращает компиляторы от создания конструктора по умолчанию для класса, для которого вы указали, что конструктору требуются аргументы.)

Сгенерированные специальные функции-члены неявно являются открытыми и встраиваемыми; они также являются не виртуальными, если только таковой функцией не является деструктор производного класса, унаследованного от базового класса с виртуальным деструктором. В этом случае генерируемый компилятором деструктор производного класса также является виртуальным.

Что касается С++11, то в клуб специальных функций-членов приняты два новых игрока: перемещающий конструктор и оператор перемещающего присваивания. Их сигнатуры имеют следующий вид:
```cpp
class Widget {
public:
	...
	Widget(Widget&& rhs);
	Widget& operator=(Widget&& rhs);
};
```
Правила, регулирующие их создание и поведение, аналогичны правилам для их копирующих двойников. Перемещающие операции генерируются только если они необходимы, и если они генерируются, то выполняют "почленное перемещение" нестатических членов-данных класса. Это означает, что перемещающий конструктор создает каждый нестатических член-данные класса из соответствующего члена его параметра `rhs` с помощью перемещения, а оператор перемещающего присваивания выполняет перемещающее присваивание каждого нестатического члена-данных из переданного ему параметра. Перемещающий конструктор также выполняет перемещающее конструирование частей базового класса (если таковые имеются), а оператор перемещающего присваивания выполняет соответственно перемещающее присваивание частей базового класса.

Когда я говорю о перемещающей операции над членом-данными или базовым классом, нет никакой гарантии, что перемещение в действительности имеет место. "Почленные перемещения" в действительности представляют собой *запросы* на почленное перемещение, поскольку типы, которые *не могут быть перемещены* (т.е. не обладают поддержкой операций перемещения; например, таковыми являются большинство старых классов С++98), будут "перемещены" с помощью операций копирования. Сердцем каждого почленного "перемещения" является применение `std::move` к объекту, из которого выполняется перемещение, а результат используется в процессе разрешения перегрузки функций для выяснения, должно ли выполняться перемещение или копирование. Этот процесс детально описывается в разделе [[Азы std move и std forward|Азы `std::move` и `std::forward`]]. В этом разделе просто помните, что почленное перемещение состоит из операций перемещения для тех членов-данных и базовых классов, которые поддерживают перемещающие операции, и из операций копирования для тех, которые перемещающие операции не поддерживают.

Как и в случае с копирующими операциями, перемещающие операции не генерируются, если вы их объявляете самостоятельно. Однако точные условия, при которых они генерируются, несколько отличаются от условий для копирующих операций.

Две копирующие операции независимы одна от другой: объявление одной не препятствует компилятору генерировать другую. Так что если вы объявляете копирующий конструктор, но не копирующий оператор присваивания, а затем пишете код, которому требуется копирующее присваивание, то компиляторы будут генерировать оператор копирующего присваивания вместо вас. Аналогично, если вы объявили оператор копирующего присваивания, но не копирующий конструктор, а вашему коду нужен копирующий конструктор, то последний будет сгенерирован компилятором вместо вас.

Две перемещающие операции не являются независимыми. Если вы объявите одну из них, это не позволит компиляторам сгенерировать вторую. Это объясняется тем, что если вы объявляете, скажем, перемещающий конструктор для вашего класса, то вы указываете, что есть что-то, что при перемещающем конструировании должно быть реализовано иначе, чем почленное перемещение по умолчанию, генерируемое компиляторами. Но если это что-то неверно при почленном перемещающем конструировании, то, вероятно, оно будет неверно и при почленном перемещающем присваивании. Поэтому объявление перемещающего конструктора предохраняет от генерации перемещающего оператора присваивания, а объявление перемещающего оператора присваивания предохраняет от генерации перемещающего конструктора.

Кроме того, перемещающие операции не будут генерироваться для любого класса, у которого явно объявлены копирующие операции. Объяснение этому заключается в том, что объявление копирующих операций (конструктора и присваивания) указывает, что обычный подход к копированию объекта (почленное копирование) не годится для этого класса, и компиляторы делают заключение, что если для класса не подходит почленное копирование, то, вероятно, почленное перемещение для него тоже не подойдет.

Этот вывод справедлив и в обратном направлении. Объявление в классе перемещающие операции (конструктора или присваивания) приводит к тому, что компиляторы не генерируют копирующие операции. (Копирующие операции отключаются с помощью их удаления)
В конце концов, если почленное перемещение не является корректным способом перемещения, то нет причин ожидать, что почленное копирование окажется корректным способом копирования. Это выглядит как возможное нарушение работоспособности кода С++98, поскольку условия, при которых разрешена генерация операций копирования, являются более ограничивающими в С++11, чем в С++98, но на самом деле это не так. Код С++98 не может иметь перемещающие операции, поскольку в С++98 нет такого понятия, как "перемещение" объектов. Единственный способ для старого класса иметь пользовательские перемещающие операции - это если они будут добавлены в коде С++11. Но классы, которые изменены таким образом, чтобы использовать преимущества семантики перемещений, обязаны играть по правилам С++11, касающимся генерации специальных функций-членов.

Вероятно, вы слышали о рекомендации о *большой тройке*. Она утверждает, что если вы объявили хотя бы одну из трех операций - копирующий конструктор, копирующий оператор присваивания или деструктор, - то вы должны объявить все три операции. Это правило вытекает из наблюдения, что необходимость изменения смысла копирующей операции почти всегда подразумевает, что
1. какое бы управление ресурсами ни выполнялось в одной копирующей операции, вероятно, такое же управление ресурсами потребуется и во второй копирующей операции;
2. деструктор класса также должен участвовать в управлении ресурсами (обычно - освобождать их).

Классическим управляемым ресурсом является память, и именно поэтому все классы стандартной библиотеки, управляющие памятью (например, контейнеры STL, управляющие динамической памятью), объявляют всю "большую тройку": обе копирующие операции и деструктор.

Следствием правила большой тройки является то, что наличие пользовательского деструктора указывает на вероятную неприменимость простого почленного копирования для копирующих операций класса. Это, в свою очередь, предполагает, что если класс объявляет деструктор, то копирующие операции, по всей вероятности, не должны генерироваться автоматически, так как они будут выполнять неверные действия. Во времена принятия С++98 важность этих рассуждений не была оценена должным образом, так что в С++98 наличие пользовательского деструктора не влияло на генерацию компиляторами копирующих операций. Это правило перешло и в С++11, но только потому, что ограничение условий, при которых могут автоматически генерироваться копирующие операции, сделает некомпилируемым слишком большое количество старого кода.

Однако рассуждения, лежащие в основе "правила большой тройки", остаются в силе, и это, в сочетании с наблюдением, что объявление копирующей операции исключает неявную генерацию перемещающих операций, обосновывает тот факт, что С++11 *не* генерирует операции перемещения для класса с пользовательским деструктором.

Таким образом, перемещающие операции генерируются (при необходимости) для классов, только если выполняются три следующие условия:
- в классе не объявлены никакие копирующие операции;
- в классе не объявлены никакие перемещающие операции;
- в классе не объявлен деструктор.

В некоторый момент аналогичные правила могут быть распространены на копирующие операции, поскольку С++11 выступает против автоматической генерации копирующих операций для классов, объявляющих копирующую операцию или деструктор. Это означает, что если у вас есть код, зависящий от генерации копирующих операций в классе с объявленным деструктором или одной из копирующих операций, то вы должны рассмотреть обновление таких классов для устранения указанной зависимости. Если поведение сгенерированных компилятором функций вас устраивает (т.е. почленное копирование нестатических членов-данных - именно то, что вам надо), то пересмотр кода будет очень простым делом, поскольку в С++11 сказать это явно позволяет простая конструкция "= default":
```cpp
class Widget {
public:
...
~Widget();

...
Widget(const Widget&) = default;

Widget& operator=(const Widget&) = default;
}
```
Этот подход часто полезен в полиморфных базовых классах, т.е. в классах, определяющих интерфейсы, посредством которых происходит управление производными классами. Обычно полиморфные базовые классы имеют виртуальные деструкторы, поскольку, если это не так, некоторые операции (например, использование `delete` или `typeid` с объектом производного класса через указатель или ссылку на базовый класс) дают неопределенный или вводящий в заблуждение результат. Если только класс не наследует деструктор, являющийся виртуальным, единственный способ сделать деструктор виртуальным - явно объявить его таковым. Зачастую реализация по умолчанию является корректной, и использовать конструкции `= default` - хороший способ выразить это. Однако пользовательский деструктор подавляет генерацию перемещающих операций, так что, если требуется поддержка перемещаемости, `= default` зачастую находит второе применение. Объявление перемещающих операций отключает копирующие операции, так что, если копируемость также желательна, это делает еще один круг `= default`:
```cpp
class Base {
public:
	virtual ~Base() = default;  // Делает деструктор виртуальным

	Base(Base&&) = default;  // Поддержка перемещения
	Base& operator=(Base&&) = default;

	Base(const Base&) = default;  // Поддержка копирования
	Base& operator=(const Base&) = default;
}
```
Фактически, даже если у вас есть класс, в котором компиляторы могут генерировать копирующие и перемещающие операции и в котором генерируемые функции ведут себя так, как надо, вы можете выбрать стратегию их объявления и применения конструкции `= default` в качестве определений. Это требует большего количества работы, но делает ваши намерения более ясными, и это может помочь обойти некоторые довольно трудные выявляемы ошибки. Предположим, например, что у нас есть класс, представляющий таблицу строк, т.е. структуру данных, которая обеспечивает быстрый поиск строкового значения по его целочисленному идентификатору:
```cpp
class StringTable {
public:
	StringTable() {}
		// Функции вставки, удаления, поиска и т.п., но нет
		// функциональности копирования/перемещения/деструкции
private:
	std::map<int, std::string> values;
};
```
