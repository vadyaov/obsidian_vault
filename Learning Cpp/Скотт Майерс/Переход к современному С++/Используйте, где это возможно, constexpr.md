При применении к объектам, это, по сути, усиленная разновидность `const`, но при применении к функциям оно имеет совсем другой смысл.

Концептуально ключевое слово `constexpr` указывает значение, которое не просто является константой, но и известно во время компиляции. Эта концепция - лишь часть всей истории, поскольку при применении `constexpr` к функциям появляется больше нюансов, чем можно предположить. Чтобы не забегать вперед, скажу, что вы *не можете считать* , что результат `constexpr` функции представляет константу, ни считать, что эти значения известны во время компиляции. Пожалуй, наиболее интригующим является то, что это *возможности* данного ключевого слова. Это *хорошо*, что `constexpr` функция не обязана давать конкретный результат, или результат, известный во время компиляции!

Начнем с объектов `constexpr`. Такие объекты являются, по сути, константными (`const`) и на самом деле обладают значениями, известными во время компиляции. (Технически их значения определяются во время *трансляции*, а трансляция состоит не только из компиляции, но и из компоновки. Однако, если вы не пишете компиляторы или редакторы связей для С++, это не имеет для вас значения, так что можете беспечно программировать так, как будто эти значения объектов `constexpr` определяются во время компиляции.)

Значения, известные во время компиляции, являются привилегированными. Они, например, могут быть размещены в памяти, предназначенной только для чтения, и это может представлять особое значение для разработчиков встроенных систем. Широко применяется то, что целочисленные значения, являющиеся константами и известные во время компиляции, могут использоваться в контекстах, где С++ требует *целочисленное константное выражение*. Такие контексты включают спецификации размеров массивов, целочисленные аргументы шаблонов (включая длину объектов `std::array`), значения перечислителей, спецификаторы выравнивая и прочее. Если вы хотите использовать для этих вещей переменные, вы, определенное захотите объявить их как `constexpr`, поскольку тогда компиляторы будут точно знать, что имеют дело со значением времени компиляции:
```cpp
int sz;                         // Неконстантная переменная
...
constexpr auto arraySize1 = sz; // Ошибка! Значение sz
                                // неизвестно при компиляции
std::array<int, sz> data1;      // Ошибка! Та же проблема
constexpr auto arraySize2 = 10; // ОК, 10 - константа
                                // времени компиляции
std::array<int,                 // ОК
		   arraySize2> data2;   
```
Обратите внимание, что `const` не предоставляет таких же гарантий, что и `constexpr`, поскольку объекты `const` не обязаны инициализироваться значениями, известными во время компиляции.

Проще говоря, все объекты, являющиеся `constexpr`, являются `const`, но не все объекты, являющиеся `const`, являются `constexr`. Если вы хотите, чтобы компиляторы гарантировали, что переменная имеет значение, которое можно использоваться в требующих константы времени компиляции контекстах, то следует использовать `constexpr`, а не `const`.

Сценарии использования объектов `constexpr` становятся более интересными, когда в дело вступают функции `constexpr`. Такие функции производят константы времени компиляции, *когда они вызываются с константами времени компиляции*. Если они вызываются со значениями, неизвестными до времени выполнения, они производят значения времени выполнения. Это может выглядеть так, как будто вы не знаете, что они будут делать, но так думать - неверно. Вот как выглядит правильный взгляд на эти моменты:

- Функции, объявленные как `constexpr`, могут использоваться в контекстах, требующих константы времени компиляции. Если значения передаваемых вами аргументов в `constexpr`- функцию в таком контексте известны во время компиляции, результат функции будет вычислен в процессе компиляции. Если любое из значений аргументов неизвестно во время компиляции, ваш код будет отвергнут.
- Когда `constexpr`- функция вызывается с одним или несколькими значениями, неизвестными во время компиляции, она действует так же, как и обычная функция, выполняя вычисления во время выполнения. Это означает, что вам не нужны две функции для выполнения одних и тех же операций, одной - для констант времени компиляции, другой - для всех прочих значений. Функция, объявленная как `constexpr`, выполняет их все.

Предположим, что нам нужна структура данных для хранения результатов эксперимента, который может быть проведен при разных условиях. Например, уровень освещения в ходе эксперимента может быть высоким, низким или освещение может быть отключено вовсе; может быть разная температура, и т.д. Если всего имеется `n` условий, влияющих на проведение эксперимента, и у каждого по три возможных состояния, то общее количество комбинация составит `3^n` значений. В предположении, что каждый результат представляет собой `int` и что `n` известно (или может быть вычислено) во время компиляции, подходящим выбором структуры данных может быть `std::array`. Однако нам требуется способ вычисления `3^n` во время компиляции. Стандартная библиотека С++ предоставляет функцию `std::pow`, обеспечивающую интересующую нас математическую функциональность, но с точки зрения наших целей имеется две проблемы:
1. `std::pow` работает с типами с плавающей точкой, а нам нужен целочисленный результат;
2. `std::pow` не является `constexpr` (т.е. не гарантирует возврат времени компиляции при переданных ей значениях времени компиляции), так что мы не можем использовать ее для указания размера `std::array`.
К счастью, мы можем написать функцию `pow`, которая нам нужна. Как это сделать, я покажу чуть позже, но сначала давайте взглянем, каким образом эта функция может быть объявлена и использована:
```cpp
constexpr                              // pow - constexpr
int pow(int base, int exp) noexcept {  // не генерирует исключений

}

constexpr auto numConds = 5;           // кол-во условий

std::array<int, pow(3, numConds)>      // results содержит
		results;                       // 3^numConds элементов
```
Вспомним, что `constexpr` перед `pow` не говорит о том, что `pow` возвращает константное значение; оно говорит, что если `base` и `exp` являются константами времени компиляции, то результат `pow` может быть использован как константа времени компиляции. Если `base` и/или `exp` не являются константами времени компиляции, то результат `pow` будет вычисляться во время выполнения. Это означает, что `pow` может быть вызвана не только для вычисления во время компиляции таких вещей, как размер `std::array`, но и в контексте времени выполнения, как здесь:
```cpp
auto base = readFromDB("base");
auto exp = readFromDB("exponent");
auto baseToExp = pow(base, exp);
```
Поскольку функции `constexpr` должны быть способны возвращать результаты во время компиляции при вызове со значениями времени компиляции, на их реализации накладываются ограничения. Эти ограничения различны в С++11 и С++14.

В С++11 функции `constexpr` могут содержать не более одной выполнимой инструкции - `return`. Это выглядит более ограничивающим, чем является на самом деле, поскольку для повышения выразительности `constexpr`- функции можно использовать две хитрости. Во первых, можно применять условный оператор `:?` вместо инструкции `if else`, а во вторых, вместо циклов можно использовать рекурсию. Таким образом, функция `pow` может быть реализована следующим образом:
```cpp
constexpr int pow(int base, int exp) noexcept {
	return (exp == 0 ? 1 : base * pow(base, exp - 1));
}
```
Этот код работает, но только очень непритязательный программист сможет назвать его красивым. В С++14 ограничения на `constexpr`- функции существенно слабее, так что становится возможной следующая реализация:
```cpp
constexpr int pow(int base, int exp) noexcept  // C++14
{
	auto result = 1;
	for (int i = 0; i < exp; ++i) result *= base;
	return result;
}
```
Функции `constexpr` ограничены приемом и возвратом только *литеральных типов* (literal types), которые, по сути, означают типы, могущие иметь значения, определяемые во время компиляции. В С++11 к ним относятся все встроенные типы за исключением `void`, но литеральными могут быть и пользовательские типы, поскольку конструкторы и прочие функции-члены также могут являться `constexpr`:
```cpp
class Point {
public:
	constexpr Point(double xValue = 0, double yVal = 0) noexcept
	: x(xVal), y(yVal) {}

	constexpr double xValue() const noexcept { return x; }
	constexpr double yValue() const noexcept { return y; }

	void setX(double newX) noexcept { x = newX; }
	void setY(double newY) noexcept { y = newY; }
private:
	double x, y;
};
```
Здесь конструктор `Point` может быть объявлен как `constexpr`, поскольку, если переданные ему аргументы известны во время компиляции, значения членов-данных созданного `Point` также могут быть известны во время компиляции. А значит, инициализированный таким образом объект `Point` может быть `constexpr`:
```cpp
constexpr Point p1(9.4, 27.7);  // OK, во время компиляции
                                // работает constexpr конструктор
constexpr Point p2(28.8, 5.3);  // То же самое
```
Аналогично функции доступа `xValue` и `yValue` могут быть `constexpr`, поскольку если они вызываются для объекта `Point` со значением, известным во время компиляции (например, объект `constexpr Point`), значения членов-данных x и y могут быть известны во время компиляции. Это делает возможным написать `constexpr`- функции, которые вызывают функции доступа `Point` и инициализируют `constexpr`- объекты результатами вызовов этих функций:
```cpp
constexpr
Point midpoint(const Point& p1, const Point& p2) noexcept
{
	return { (p1.xValue() + p2.xValue()) / 2,
			 (p1.yValue() + p2.yValue()) / 2};
}

constexpr auto mid = midpoint(p1, p2);
```
Это очень интересно. Это означает, что объект `mid` может быть создан в памяти, предназначенной только для чтения, несмотря на то что его инициализация включает вызовы конструкторов, функций доступа и функции, не являющейся членом! Это означает, что вы можете использовать выражение наподобие `mid.xValue() * 10` в аргументе шаблона или в выражении, определяющим значение перечислителя!
>[!info]
>Поскольку `Point::xValue` возвращает `double`, типом `mid.xValue() * 10` также является `double`. Типы с плавающей точкой не могут использоваться для инстанцирования шаблонов или для указания значений перечислений, но они могут быть использованы как части больший выражений, дающих интегральные типы. Например, для инстанцирования шаблона или для указания значения перечислителя может использоваться выражение `static_cast<int>(mid.xValue()*10`.

Это означает, что традиционно довольно строгая граница между работой во время компиляции и работой во время выполнения начинает размываться, и некоторые вычисления, традиционно являющиеся вычислениями времени выполнения, могут перейти на стадию компиляции. Чем больший код участвует в таком переходе, тем быстрее будет работать ваша программа. (Однако компилироваться она может существенно дольше)

В С++11 два ограничения предотвращают объявление функций-членов `Point setX` и `setY` как `constexpr`. Во-первых, они модифицируют объект, с которым работают, а в С++11 функции-члены `constexpr` неявно являются `const`. Во вторых, они имеют возвращаемый тип `void`, а `void` не является литеральным типом в С++11. Оба эти ограничения сняты в С++14, так что в С++14 даже функции установки полей `Point` могут быть объявлены как `constexpr`:
```cpp
class Point {
public:
	constexpr vold setX(double newX) noexcept
	{ x = newX; }

	constexpr void setY(double newY) noexcept
	{ y = newY; }
}
```
Это делает возможным написание функций наподобие следующей:
```cpp
// Возвращает отражение точки p
// относительно начала координат (С++14)
constexpr Point reflection(const Point& p) noexcept
{
	Point result;              // Неконстантный объект Point
	result.setX(-p.xValue());  // Установка его полей x и y
	result.setY(-p.yValue());
	return result;             // Возврат копии
}
```
Соответствующий клиентский код имеет вид:
```cpp
constexpr Point p1(9.4, 27.7);
constexpr Point p2(28.8, 5.3);
constexpr auto mid = midpoint(p1, p2);
constexpr auto reflectedMid = reflection(mid);
```

Совет из этого раздела заключается в том, чтобы использовать `constexpr` везде, где это только возможно, и теперь, надеюсь, вам понятно, почему: и объекты `constexpr`, и `constexpr`- функции могут применяться в более широком диапазоне контекстов, чем объекты и функции, не являющиеся `constexpr`. Применяя `constexpr`, где это возможно, вы максимизируете диапазон ситуаций, в которых ваши объекты и функции могут быть использованы.

Важно отметить, что `constexpr` является частью интерфейса объекта или функции. `constexpr` провозглашает:
> Меня можно использовать в контексте, где для С++ требуется константное выражение.

Если вы объявляете объект или функцию как `constexpr`, клиенты могут использовать их в указанных контекстах. Если позже вы решите, что такое использование `constexpr` было ошибкой, и удалите его, то это может привести к тому, что большое количество клиентского кода перестанет компилироваться. (Простое действие, заключающееся в добавлении в функцию отладочного вывода для отладки или настройки производительности может привести к таким проблемам, поскольку инструкции ввода-вывода в общем случае в `constexpr`- функциях недопустимы.) Часть "где это возможно" совета является вашей доброй волей на придание долгосрочного характера данному ограничению на объекты и функции, к которым вы его применяете.
>[!note] Следует запомнить
>- Объекты `constexpr` являются константными и инициализируются объектами, значения которых известны во время компиляции.
>- Функции `constexpr` могут производить результаты времени компиляции при вызове с аргументами, значения которых известны во время компиляции.
>- Объекты и функции `constexpr` могут использоваться в более широком диапазоне контекстов по сравнению с объектами и функциями, не являющимися `constexpr`.
>- `constexpr` является частью интерфейса объектов и функций.

