Можно рассматривать шаблон функции как имеющий следующий вид:
```cpp
template<typename T>
void f(ParamType param);
```
Вызов может выглядеть следующим образом:
```cpp
f(expr); // Вызов f с некоторым выражением
```
В процессе компиляции компилятор использует `expr` для вывода двух типов: типа `T` и типа `ParamType`.
Эти типы зачастую различны, поскольку `ParamType` часто содержит "украшения", например `const` или квалификаторы ссылки. Например, если шаблон объявлен как
```cpp
template<typename T>
void f(const T& param); // ParamType - const T&
```
и мы осуществляем вызов
```cpp
int x = 0;

f(x); // вызов f() c параметром int
```
то `T` выводится как `int`, a `ParamType` - как `const int&`.

Вполне естесственно ожидать, что тип, выведенный для T, тот же, что и тип переданного функции аргумента, т.е. что `T` - это тип выражения `expr`. 

### Случай 1. `ParamType` явялется указателем или ссылкой, но не универсальной ссылкой
Простейшая ситуация - когда `ParamType` является ссылочным типом указателя, но не универсальной ссылкой. В этом случае вывод типа работает следующим образом:
1. Если типом `expr` является ссылка, ссылочная часть игнорируется.
2. Затем выполняется сопоставление типа `expr` с `ParamType` для определения `T`.

Например, если у нас имеются шаблон
```cpp
template<typename T>
void f(T& param); // param представляет собой ссылку
```
и объявления переменных
```cpp
int x = 27;        // x имеет тип int
const int cx = x;  // cx имеет тип const int
const int& rx = x; // rx является ссылкой на x как на const int
```
то выводимые типы для `param` и `T` в различных выводах будут следующими:
```cpp
f(x);  // тип T - int, тип param - int&
f(cx); // тип T - const int, тип param - const int&
f(rx); // тип T - const int, тип param - const int& 
```
Во втором и третьем вызовах, поскольку `cx` и `rx` объявлены как константные значения, `T` выводится как `const int`, тем самым приводя к типу параметра`const int&`.
Это важно для вызывающего кода. Передавая константый объект параметру-ссылке, он ожидает, что объект останется неизменным, т.е. что параметр будет представлять собой ссылку на `const`.
Вот почему передача константного объектра в шаблон, получающий параметр `T&`, безопасна: константность объекта становится частью выведенного для `T` типа.

В третьем примере, несмотря на то, что типом `rx` является ссылка, тип `T` выводится как не ссылочный. Вот почему при выводе типа игнорируется ссылочность `rx`.

Все эти примеры показывают сслылочные параметры, являющиеся `lvalue`, но вывод типа точно так же работает и для ссылочных параметров `rvalue`.
Конечно, `rvalue`- аргументы могут передаваться только ссылочным параметрам, являющимся `rvalue`, но это ограничение никак не влияет на вывод типов.

Если мы изменим тип параметра `f` с `T&` на `const T&`, произойдут небольшие изменения, но ничего удивительного не случится. Константность `cx` и `rx` продолжает соблюдаться, но поскольку теперь мы считаем, что `param` является ссылкой на `const`, `const` как часть выводимого типа `T` не требуется:
```cpp
template<typename T>
void f(const T& param); // param является ссылкой на const

int x = 27;
const int cx = x;
const int& rx = x;

f(x);  // тип T - int, тип param - const int&
f(cx); // тип T - int, тип param - const int&
f(rx); // тип T - int, тип param - const int&
```
Как и ранее, "ссылочность" `rx` при выводе типа игнорируется.

Если бы `param` был указателем (или указателем на `const`), а не ссылкой, все бы работало, по сути, точно так же:
```cpp
template<typename T>
void f(T* param);   // теперь param является указателем

int x = 27;         // Как и ранее
const int *px = &x; // px - указатель на х как на const int

f(&x); // T - int, param - int*
f(px); // T - cosnt int, param - const int*
```
### Случай 2. `ParamType` является универсальной ссылкой
Все становится менее очевидным в случае шаблонов, принимающих параметры, являющиеся универсальными ссылками. 
Такие параметры объявляются как ссылки `rvalue` (т.е. в шаблоне функции, принимающем параметр типа `T`, объявленным типом универсальной ссылки является `T&&`), но ведут себя иначе при передаче аргументов, являющихся `lvalue`.
Послностью вопрос рассматривается [[Отличие универсальных ссылок от rvalue-ссылок | тут]], здесь приводится его сокращенная версия.
- Если `expr` представляет собой `lvalue`, как `T`, так и `ParamType` выводятся как `lvalue`- ссылки. Это вдвойне необычно.
	- Во-первых, ==это единственная ситуация в выводе типа шаблона, когда `T` выводится как ссылка==.
	- Во вторых, хотя `ParamType` объявлен с использованием синтаксиса `rvalue`- ссылки, его выводимым типом является `lvalue`- ссылка.
- Если `expr` представляет собой `rvalue`, применяются "обычные" правила ([[#Случай 1. `ParamType` явялется указателем или ссылкой, но не универсальной ссылкой | случай 1]]).

```cpp
template<typename T>
void f(T&& param); // param является универсальной ссылкой

int x = 27;
const int cx = x;
const int& rx = x;

f(x);  // x - lvalue, T - int&,
       // тип param также является int&
f(cx); // cx - lvalue, T - const int&,
       // тип param также является const int&
f(rx); // rx - lvalue, T - const int&,
       // тип param также является const int&
f(27); // 27 - rvalue, так что T - int,
       // тип param - int&&
```
В [[Отличие универсальных ссылок от rvalue-ссылок | разделе]]поясняется, почему эти примерв работают именно так, а не иначе.
Ключевым моментом является то, что правила вывода типов для параметров, являющихся универсальными ссылками, отличаются от таковых для параметров, являющихся `lvalue`- или `rvalue`-ссылками.
В частности, когда используются универсальные ссылки, вывод типов различает аргументы, являющиеся `lvalue`, и аргументы, являющиеся `rvalue`. Этого никогда не происходит для неуниверсальных ссылок.
### Случай 3. `ParamType` не является ни указателем, ни ссылкой
Когда `ParamType` не является ни указателем, ни ссылкой, мы имеем дело с передачей по значению:
```cpp
template<typename T>
void f(T param);    // param передается по значению
```
Это означает, что `param` будет копией переданного функции - совершенно новым объектом.
Тот факт, что `param` будет совершенно новым объектом, приводит к правилам, которые регулируют вывод `T` из `expr`.
1. Как и ранее, если типом `expr` является ссылка, ссылочная часть игнорируется.
2. Если после отбрасывания ссылочной части `expr` является `const`, это также игнорируется. Игнорируется и модификатор `volatile` (объекты `volatile` являются редкостью и в общем случае используются только при реализации драйверов устройств; детальная инфрмация на эту тему можно найти [[Используйте stdatomic для параллельности, volatile - для особой памяти | тут]])

Таким образом, получаем следующее:
```cpp
int x = 27;
const int cx = x;
const int& rx = x;

f(x);  // Типами и T и param являются int
f(cx); // Типами и T и param являются int
f(rx); // Типами и T и param являются int
```
Даже несмотря на то, что `cx` и `rx` представляют константные значения, `param` не является `const`. Это имеет смысл, так как `param` представляет собой объект, который полностью независим от `cx` и `rx`, - это копия `cx` и `rx`.
Тот факт, что `cx` и `rx` не могут быть модифицированы, ничего не говорит о том, может ли быть модифицирован `param`. Вот почему константность `expr` при выводе типа сохраняется.

Но рассмотрим случай, когда `expr` представляет собой `const`- указатель на константный объект, а передача осуществляется по значению:
```cpp
template<typename T>
void f(T param); // param передается по значению

const char* const ptr =  // ptr - const указатель на
	"Fun with pointers"; // константный объект

f(ptr); // передача arg типа const char* const
```
Здесь `const` справа от звездочки объявляет `ptr` константным:
`ptr` не может ни указывать в другое место памяти, ни быть обнуленным.

Когда `ptr` передается в функцию `f`, биты, составляющие указатель, копируются в `param`. Как таковой *сам указатель будет передан по значению*.

В соответствии с правилом вывода типа при передаче параметров по значению константность `ptr` будет проигнорирована, а выведенным для `param` типом будет `const char*`, т.е. изменяемый указатель на константную строку символов.
Константность того, на что указывает `ptr` в процессе вывода типа сохраняется, но константность самого `ptr` игнорируется при создании нового указателя `param`.

### Аргументы - массивы
Еще один угол, в который стоит заглянуть - отличие типов массивов от типов указателей, несмотря на то что зачастую они выглядят взаимозаменяемыми.
Основной вклад в эту иллюзию вносит то, что во множестве контекстов массив преобразуется в указатель на его первый элемент. Это преобразование позволяет компилироваться коду наподобие следующего:
```cpp
const char name[] = "Briggs"; // тип name - const char[7]
const char* ptrToName = name; // массив стал указателем
```
Здесь указатель `ptrToName` типа `const char*` инициализируется переменной `name`, которая имеет тип `const char[7]`
Эти типы (`const char*` и `const char[7]`) не являются одним и тем же типом, но благодаря правилу преобразования массива в указатель приведенный выше код компилируется.

Но что будет, если передать массив шаблону, принимающему параметр по значению?
```cpp
template<typename T>
void f(T param);

f(name);   // Какой тип T и param будет выведен?
```
Начнем с наблюдения, что не существует такой вещи, как параметр функции, являющийся массивом, хотя и приведенный далее синтаксис корректен:
```cpp
void myFunc(int param[]);
```
Однако объявление массива рассматривается как объявление указателя, а это означает что функция `myFunc` может быть эквивалентно объявлена как
```cpp
void myFunc(int* param); // Та же функция, что и ранее
```
Эта эквивалентность параметров, представляющих собой массив и указатель, представляет собой немного листвы от корней С на дереве С++ и способствует возникновению иллюзии, что типы массивов и указателей представляют собой одно и то же.

Поскольку объявление параметра-массива рассматривается так, как если бы это было объвление параметра-указателя, тип массива, передаваемого в шаблонную функцию по значению, выводится как тип указателя. Это означает, что в вызове шаблонной функции `f` ее параметр типа `T` выводится как `const char*`:
```cpp
f(name); // name - массив, но T - const char*
```
А вот теперь начинаются настоящие хитрости. Хотя функции не могут объявлять параметры как истинные массивы, ==они *могут* объявлять параметры, явялющиеся *ссылками* на массивы==! Так что если мы изменим шаблон `f` так, чтобы он получал свой аргумент по ссылке,
```cpp
template<typename T>
void f(T& param); // Шаблон с передачей параметра по ссылке
```
и передадим ему массив
```cpp
f(name); // Передача массива функции f
```
то тип, выведенный для `T`, будет в действительности типом массива! Этот тип включает размер массива, так что в нашем примере `T` выводится как `const char[7]`, а типом параметра `f` (ссылки на этот массив) является `const char (&)[7]`.

Возможность объявлять ссылки на массивы позволяет создать шаблон, который выводит количество элементов, содержащихся в массиве:
```cpp
// Возвращает размер массива как константу времени компиляции
// Параметр не имеет имени, поскольку, кроме количества содержащихся в нем элементов, нас ничто не интересует
template<typename T, std::size_t N>
constexpr std::size_t arraySize(T (&)[N]) noexcept
{
	return N;
}
```
Объявление этой функции как `constexpr` делает ее результат доступным во время компиляции. Это позволяет объявить, например, массив с таким же количеством элементов, как и у второго массива, размер которого вычисляется из инициализатора в фигурных скобках:
```cpp
// keyVals содержит 7 элементов
int keyVals[] = {1, 3, 7, 9, 11, 22, 35};

int mappedVals[arraySize(keyVals)]; // mappedVals - тоже
// или
std::array<int, arraySize(keyVals)> mappedVals;
```

### Аргументы - функции
Массивы - не единственные сущности в С++, которые могут превращаться в указатели. Типы функций могут превращатся в указатели на функции, и все, что мы говорили о выводе типов для массивов, применимо к выводу типов для функций и их преобразованию в указатели на функции. В результате получаем следующее:
```cpp
void someFunc(int, double);

template<typename T>
void f1(T param); // param передается по значению

template<typename T>
void f2(T& param); // param передается по ссылке

f1(someFunc); // param выводится как указатель на функцию
              // тип - void(*)(int, double)

f2(someFunc); // param выводится как ссылка на функцию
              // тип - void(&)(int, double)
```

>[!info]- Следует запомнить
>- В процессе вывода типа шаблона аргументы, являющиеся ссылками, рассматриваются как ссылками не являющиеся, т.е. их "ссылочность" игнорируется.
>- При выводе типов для параметров, являющихся универсальными ссылками, `lvalue`- аргументы рассматриваются специальным образом.
>- При выводе типов для параметров, передаваемых по значению, агрументы, объявленные как `const` и/или `volatile`, рассматриваются как не являющиеся ни `const`, ни `volatile`.
>- В процессе вывода типа шаблона аргументы, являющиеся именами массивов или функций, преобразуются в указатели, если только они не использованы для инициализации ссылок.
