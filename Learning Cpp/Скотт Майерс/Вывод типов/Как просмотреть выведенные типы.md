Выбор инструментов для просмотра результатов вывода типа зависит от фазы процесса разработки программного обеспечения, на которой вы хотите получить эту информацию. Мы рассмотрим три возможности:
- при редактировании кода;
- во время компиляции;
- во время выполнения.
#### Редакторы IDE
Редакторы исходных текстов в IDE часто показывают типы программных сущностей, когда вы помещаете указатель мыши над ними. Например,
```cpp
const int theAnswer = 42;
auto x = theAnswer;
auto y = &theAnswer;
```
Редактор, скорее всего, покажет, что выведенный тип `x` представляет собой `int`, а выведенный тип `y` - `const int*`.
Чтобы это работало, код должен быть в более-менее компилируемом состоянии, поскольку такого рода информация поставляется среде разработки компилятором С++, работающим в IDE. Если компилятор не в состоянии получить достаточно информации о вашем коде, чтобы выполнить вывод типа, вы не сможете увидеть выведенные типы.
Для простых типов наподобие `int` информация в IDE вполне точна. Однако, когда приходится иметь дело с более сложными типами, информация, выводимая в IDE, может оказаться не особенно полезной.

#### Диагностика компилятора
Эффективный способ заставить компилятор показать выведенный тип - использовать данный тип так, чтобы это привело к проблемам компиляции. Сообщения об ошибке практически обязательно будет содержать тип, который к ней привел.
Предположим, например, что мы хотели узнать типы, выведенные для `x` и `y` из предыдущего примера. Сначала мы объявляем шаблон класса, но *не* *определяем* его. Чего-то такого вполне хватит:
```cpp
template<typename T> // Только объявление TD
class TD;
```
Попытки инстанцировать этот шаблон приведут к сообщению об ошибке, поскольку инстанцируемый шаблон отсутствует. Чтобы увидеть типы `x` и `y`, просто попробуйте инстанцировать `TD` с их типами:
```cpp
TD<decltype(x)> xType; // Сообщение об ошибке 
TD<decltype(y)> yType; // будет содержать типы x и y
```
> error: aggregate `TD<int> xType` has incomplete and cannot be defined
> error: aggregate `TD<const int*> yType` has incomplete type and cannot be defined

Другой компилятор выдает ту же информацию, но в несколько другом виде:
> error: `xType` used undefined class `TD<int>`
> error: `yType` used undefined class `TD<const int*>`

Если не учитывать разницу в оформлении, компиляторы генерируют сообщения об ошибках с интересующей информацией о типах.

#### Вывод времени выполнения
Подход с использованием функции вывода для отображения сведений о типе может быть использован только во время выполнения программы, зато он предоставляет полный контроль над форматированием вывода. Вопрос в том, чтобы создать подходящее для вывода текстовое представление информации.
> Без проблем, - скажете вы. - Нам на помощь придут `typeid` и `std::type_info::name`

Этот подход основан на том факте, что вызов `typeid` для такого объекта, как `x` или `y`, дает объект `std::type_info`, а он имеет функцию-член `name`, которая дает C-строку (т.е. `const char*`), представляющую имя типа.

Не гарантируется, что вызов `std::type_info::name` вернет что-то разумное, но его реализации изо всех сил пытаются быть полезными. Уровень этой полезности варьируется от компилятора к компилятору. Компиляторы `GNU` и `Clang`, например, сообщают, что тип `x` - это "i", а тип `y` - "PKi". Эти результаты имеют смысл, если вы будете знать, что "i" у данных компиляторов означает "int", а "PK" - "указатель на константу" (Оба компилятора поддерживают инструмент с++filt, который расшифровывает эти имена). Компилятор Microsoft генерирует менее зашифрованный вывод: "int" для `x` и "int const*" для `y`.

Поскольку это корректные результаты для типов `x` и `y`, можно подумать, что задача получения информации о типах решена, но не делайте скоропалительных выводов. Рассмотрим более сложный пример.
```cpp
template<typename T>                // Шаблонная функция
void f(const T& param);             // вызываемая далее

std::vector<Widget> createVec();    // Фабричная функция

const auto vw = createVec();        // Инициализация vw возвратом функции

if (!vw.empy()) {
	f(&vw[0]);                      // Вызов f
}
```
Этот код, включающий пользовательский тип, контейнер STL (`std::vector`) и переменную `auto` (`vw`), является более представительным и интересным примером. Было бы неплохо узнать, какие типы выводятся для параметра типа шаблона `T` и для параметра `param` функции `f`.
Воспользоваться `typeid` в этой задаче достаточно просто. Надо всего лишь добавить немного кода в функцию `f`  для вывода интересующих нас типов:
```cpp
template<typename T>
void f(const T& param) {
	using std::cout;

	// Вывод в поток cout типа T:
	cout << "T = " << typeid(T).name() << '\n';

	// Вывод в поток cout типа param
	cout << "param = " << typeid(param).name() << '\n';
}
```
Выполнимые файлы, полученные с помощью компиляторов GNU и Clang, дают следующий результат:
```cpp
T     = PK6Widget
param = PK6Widget
```
Мы уже знаем, что в этих компиляторах `PK` означает указатель на константу, так что вся загадка - в цифре 6. Это просто количество символов в следующем за ней имени класса (Widget). Таким образом, данные компиляторы сообщают нам, что и `T`, и `param` имеют один и тот же тип - `const Widget*`.
Компилятор Microsoft согласен:
```cpp
T     = class Widget const *
param = class Widget const *
```
Три независимых компилятора дают одну и ту же информацию, что свидетельствует о том, что эта информация является точной. Но давайте посмотрим более внимательно. В шаблоне `f` объявленным типом `param` является тип `const T&`. В таком случае не кажется ли вам странным, что и `T`, и `param` имеют один и тот же тип? Если тип `T`, например, представляет собой `int`, то типом `param` должен быть `const int&` - совершенно другой тип.

К сожалению, результат `std::type_info::name` ненадежен. Например, в данном случае тип, который все три компилятора приписывают `param`, является неверным.
Кроме того, он по сути *обязан* быть неверным, так как спецификация `std::type_info::name` разрешает, чтобы тип рассматривался как если бы он был передан в шаблонную функцию по значению. Как поясняется в разделе [[Вывод типа шаблона]], это означает, что если тип является ссылкой, то его "ссылочность" игнорируется, а если тип после удаления ссылочности оказывается `const` или `volatile`, то соответствующие модификаторы также игнорируются. 

Вот почему информация о типе `param` - который на самом деле является `const Widget* const&` - выводится как `const Widget*`. Сначала удаляется ссылочность, а затем у получившегося указателя удаляется константность.