`decltype` - создание странное. Для данного имени или выражения `decltype` сообщает вам тип этого имени или выражения. Обычно то, что сообщает `decltype`, - это именно то, что вы предсказываете. Однако иногда он дает результаты, которые заставляют вас чесать в затылке.

Начнем с типичных случаев, в которых нет никаких подводных камней. В отличие от того, что происходит в процессе вывода типов для [[Learning Cpp/Скотт Майерс/Вывод типов/Вывод типа шаблона.md|шаблонов]] и [[Learning Cpp/Скотт Майерс/Вывод типов/Вывод типа auto.md|auto]], `decltype` обычно попугайничает, возвращая точный тип имени или выражения, которое вы передаете ему:
```cpp
const int i = 0;         // decltype(i) - const int

bool f(const Widget& w); // decltype(w) - const Widget&
                         // decltype(f) - bool(const Widget&)
struct Point {
	int x, y;            // decltype(Point::x) - int
};                       // decltype(Point::y) - int

Widget w;                // decltype(w) - Widget

if (f(w)) ...            // decltype(f(w)) - bool

template<typename T>     // упрощенная версия std::vector
class vector {
public:
	...
	T& operator[](std::size_t index);
};

vector<int> v;           // decltype(v) - vector<int>
...
if (v[0] == 0) ...       // decltype(v[0]) - int&
```
Никаких сюрпризов.

Пожалуй, основное применение `decltype` в C++ - объявление шаблонов функций, в которых возвращаемый тип функции зависит от типов ее параметров.

Предположим, например, что мы хотим написать функцию, получающую контейнер, который поддерживает индексацию с помощью квадратных скобок с индексом, а затем аутентифицирует пользователя перед тем как вернуть результат операции индексации.
`operator[]` для контейнера объектов типа `T` обычно возвращает `T&`. Например, это так в случае `std::deque` и почти всегда - в случае `std::vector`. Однако для `std::vector<bool>` оператор `operator[]` не возвращает `bool&`. Вместо этого он возвращает новый объект. Причины такого поведения рассматриваются в другом [[Learning Cpp/Скотт Майерс/Объявление auto/Если auto выводит нежелательный тип, используйте явно типизированный инициализатор.md|разделе]], но главное здесь то, что возвращаемый оператором `operator[]` контейнера тип зависит от самого контейнера.

`decltype` упрощает выражение этой зависимости. Вот пример, показывающий применение `decltype` для вычисления возвращаемого типа. Этот шаблон требует уточнения, но пока что мы его отложим.
```cpp
template<typename Container, typename Index> // работает, но
auto authAndAccess(Container& c, Index i)    // требует
	-> decltype(c[i])                        // уточнения
{
	authenticateUser();
	return c[i];
}
```
Использование `auto` перед именем функции не имеет ничего общего с выводом типа. На самом деле оно указывает, что использован синтаксис C++11 - *завершающий возвращаемый тип* (trailing return type), т.е. что возвращаемый тип функции будет объявлен после списка параметров (после "->").
Завершающий возвращаемый тип обладает тем преимуществом, что в спецификации возвращаемого типа могут использоваться параметры функции. В `authAndAccess`, например, мы указываем возвращаемый тип с использованием `c` и `i`.
Если бы возвращаемый тип, как обычно, предшествовал имени функции, `c` и `i` были бы в нем недоступны, поскольку в этот момент они еще не были объявлены.

При таком объявлении `authAndAccess` возвращает тот тип, который возвращает `operator[]` при применении к переданному контейнеру, в точности как мы хотели.

С++11 разрешает вывод возвращаемых типов лямбда-выражений из одной инструкции, а С++14 расширяет эту возможность на все лямбда-выражения и все функции, включая состоящие из множества инструкций.
В случае `authAndAccess` это означает, что в С++14 мы можем опустить завершающий возвращаемый тип, оставляя только одно ведущее ключевое слово `auto`. При таком объявлении `auto` означает, что компиляторы будут выводить возвращаемый тип функции из ее реализации:
```cpp
template<typename Container, typename Index>  // C++14
auto authAndAccess(Container& c, Index i)     // Не совсем корректно
{
	authenticateUser();
	return c[i]; // Возвращаемый тип выводится из c[i]
}
```
В [[Learning Cpp/Скотт Майерс/Вывод типов/Вывод типа auto.md|разделе про вывод типа auto]] поясняется, что для функций с `auto`-спецификацией возвращаемого типа компиляторы применяют вывод типа шаблона. В данном случае это оказывается проблематичным. Как уже говорилось, `operator[]` для большинства контейнеров с объектами типа `T` возвращает `T&`, но в разделе [[Вывод типа шаблона]] поясняется, что в процессе вывода типа шаблона "ссылочность" инициализирующего выражения игнорируется. Рассмотрим, что это означает для следующего клиентского кода:
```cpp
std::deque<int> d;
...
authAndAccess(d, 5) = 10; // Аутентифицирует пользователя,
						  // возвращает d[5], затем приписывает ему
						  // значение 10. 
// Код не компилируется!
```
Здесь `d[5]` возвращает `int&`, но вывод возвращаемого типа `auto` для `authAndAccess` отбрасывает ссылку,  тем самым давая возвращаемый тип `int`. Этот `int`, будучи возвращаемым значением функции, является `rvalue`, так что приведенный выше код пытается присвоить этому `rvalue` типа `int` значение 10. Это запрещено в С++, так что данный код не компилируется.

Чтобы заставить `authAndAccess` работать так, как мы хотим, нам надо использовать для ее возвращаемого типа вывод типа `decltype`, т.е. указать, что `authAndAccess` должна возвращать в точности тот же тип, что и выражение `c[i]`. Это возможно сделать, начиная с С++14, с помощью `decltype(auto)`.
То, что поначалу может показаться противоречием (`decltype` и `auto`?), в действительности имеет смысл: `auto` указывает, что тип должен быть выведен, а `decltype` говорит о том, что в процессе вывода следует использовать правила `decltype`.
Итак, можно записать `authAndAccess` следующим образом:
```cpp
template<typename Container, typename Index> // С++14; работает,
decltype(auto)                               // но все еще
authAndAccess(Container& c, Index i)         // требует уточнения
{
	authenticateUser();
	return c[i];
}
```
Теперь `authAndAccess` действительно возвращает то же, что и `c[i]`. В частности, в распространенном случае, когда `c[i]` возвращает `T&`, `authAndAccess` также возвращает `T&`, и в том редком случае, когда `c[i]` возвращает объект, `authAndAccess` также возвращает объект.

Использование `decltype(auto)` не ограничивается возвращаемыми типами функций. Это также может быть удобно для объявления переменных, когда вы хотите применять правила вывода типа `decltype` к инициализирующему выражению:
```cpp
Widget w;
const Widget& cw = w;

auto myWidget1 = cw;            // Вывод типа auto:
                                // тип myWidget1 - Widget


decltype(auto) myWidget2 = cw;  // Вывод типа decltype:
                                // тип myWidget2 - const Widget&
```

Еще раз посмотрим на версию `authAndAccess` в С++14:
```cpp
template<typename Container, typename Index>
decltype(auto) authAndAccess(Container& c, Index i);
```
Контейнер передается как `lvalue`-ссылка на неконстантный объект, поскольку возвращаемая ссылка на элемент контейнера позволяет клиенту модифицировать этот контейнер.
Но это означает, что этой функции невозможно передавать контейнеры, являющиеся `rvalue`. `rvalue` невозможно связать с `lvalue`-ссылками (если только они не являются `lvalue`-ссылками на константные объекты, что в данном случае очевидным образом не выполняется).

Вообще, передача контейнера, являющегося `rvalue`, в `authAndAccess` является крайним случаем. Такой `rvalue`-контейнер, будучи временным объектом, обычно уничтожается в конце инструкции, содержащей вызов `authAndAccess`, а это означает, что ссылка на элемент в таком контейнере (то, что должна вернуть функция `authAndAccess`) окажется "висячей" в конце создавшей его инструкции.

Тем не менее передача временного объекта функции `authAndAccess` может иметь смысл. Например, клиент может просто хотеть сделать копию элемента во временном контейнере:
```cpp
std::deque<std::string> makeStringDeque(); // Фабричная функция

// Делаем копию пятого элемента deque, возврщаемого
// функцией makeStringDeque
auto s = authAndAccess(makeStringDeque(), 5);
```
Поддержка такого использования означает, что мы должны пересмотреть объявление функции `authAndAccess`, которая должна принимать как `lvalue`, так и `rvalue`.
Можно использовать перегрузку (одна функция объявлена с параметром, представляющим собой `lvalue`- ссылку, а вторая - с параметром, представляющим собой `rvalue`- ссылку), но тогда нам придется поддерживать две функции. Избежать этого можно, если у нас будет функция `authAndAccess`, использующая ссылочный параметр, который может быть связан как с `lvalue`, так и с `rvalue`, и в разделе [[Отличие универсальных ссылок от rvalue-ссылок]] поясняется, что это именно то, что делают универсальные ссылки.
Таким образом, `authAndAccess` может быть объявлена следующим образом:
```cpp
template<typename Container, typename Index>         // Теперь с =
decltype(auto) authAndAccess(Container&& c, Index i);// универсальная ссылка
```
В этом шаблоне мы не знаем, с каким типом контейнера работаем, и точно так же не знаем тип используемых им индексных объектов. Использование передачи по значению для объектов неизвестного типа обычно сопровождается риском снижения производительности из-за ненужного копирования, проблемами со срезкой объектов и насмешками коллег. Но в случае индексов контейнеров, следуя примеру стандартной библиотеки для значений индексов (например, в `operator[]` для `std::string`, `std::vector` и `std::deque`) это решение представляется разумным, так что мы будем придерживаться для них передачи по значению.

Однако нам нужно обновить реализацию шаблона для приведения его в соответствие с предостережениями из раздела [[Используйте std move для rvalue-ссылок, а std forward - для универсальных ссылок|Используйте std::move для rvalue-ссылок]] о применении `std::forward` к универсальным ссылкам:
```cpp
template<typename Container, typename Index>  // Окончательная
decltype(auto)                                // версия для С++14
authAndAccess(Container&& c, Index i)
{
	authenticateUser();
	return std::forward<Container>(c)[i];
}
```
Этот код должен делать все, что мы хотели, но он требует компилятора C++14. Если у вас нет такового, вам следует использовать версию шаблона для С++11.
Она такая же, как и ее аналог С++14, за исключением того, что вы должны самостоятельно указать возвращаемый тип:
```cpp
template<typename Container, typename Index> // Окончательная версия
auto                                         // для С++11
authAndAccess(Container&& c, Index i)
->decltype(std::forward<Container>(c)[i])
{
	authenticateUser();
	return std::forward<Container>(c)[i];
}
```

Вторым беспокоящим моментом является замечание в начале этого раздела о том, что `decltype` *почти* всегда дает тип, который вы ожидаете, т.е. что он *редко* преподносит сюрпризы. Вряд ли вы столкнетесь с этими исключениями из правила, если только вы не занимаетесь круглосуточно написанием библиотек.

Чтобы полностью понимать поведение `decltype`, вы должны познакомиться с некоторыми особыми случаями. Большинство из них слишком невразумительные, но один из них приводит к лучшему пониманию `decltype`.

Применение `decltype` к имени дает объявленный тип для этого имени. Имена представляют собой `lvalue`- выражения, но это не влияет на поведение `decltype`. Однако для `lvalue`- выражений, более сложных, чем имена, `decltype` гарантирует, что возвращаемый тип всегда будет `lvalue`- ссылкой.
Иначе говоря, если `lvalue`- выражение, отличное от имени, имеет тип `T`, то `decltype` сообщает об этом типе как об `T&`. Это редко на что-то влияет, поскольку тип большинства `lvalue`- выражений в обязательном порядке включает квалификатор `lvalue`- ссылки. Например, функции, возвращающие `lvalue`, всегда возвращают `lvalue`- ссылки.

Однако у этого поведения есть следствия, о которых необходимо знать. В коде `int x = 0;` `x` является именем переменной, так что `decltype(x)` представляет собой `int`. Однако "заворачивание" имени `x` в скобки - "`(x)`" - дает выражение, более сложное, чем имя.
Будучи именем, `x` представляет собой `lvalue`, и С++ также определяет выражение `(x)` как `lvalue`. Следовательно, `decltype((x))` представляет собой `int&`. 
>[!info]
>Добавление скобок вокруг имени может изменить тип, возвращаемый для него `decltype`!

В С++11 это просто любопытный факт, но в сочетании с поддержкой в С++14 `decltype(auto)` это означает, что, казалось бы, тривиальный изменения в способе записи инструкции `return` могут повлиять на выводимый тип функции:
```cpp
decltype(auto) f1()
{
	int x = 0;
	...
	return x;     // decltype(x) представляет собой int,
}                 // так что f1 возвращает int

decltype(auto) f2()
{
	int x = 0;
	...
	return (x);   // decltype((x)) представляет собой int&,
}                 // так что f2 возвращает int&
```
Обратите внимание, что `f2` не только имеет возвращаемый тип, отличный от
`f1`, но и возвращает ссылку на локальную переменную! Этот код ведет к неопределенному поведению, что вряд ли является вашей целью.

Основной урок состоит в том, чтобы при использовании `decltype(auto)` уделять деталям самое пристальное внимание. Кажущиеся совершенно незначительными делали в выражении, для которого выводится тип, могут существенно повлиять на тип, возвращаемый `decltype(auto)`. Чтобы гарантировать, что выводимый тип - именно тот, который вы ожидаете, используйте методы описанные в разделе [[Как просмотреть выведенные типы]].

В то же время не забывайте и о более широкой перспективе. Конечно, `decltype` (как автономный, так и в сочетании с `auto`) при выводе типов иногда может привести к сюрпризам, но это не нормальная ситуация.
Как правило, `decltype` возвращает тот тип, который вы ожидаете. Это особенно верно, когда `decltype` применяется к именам, потому что в этом случае `decltype` делает именно то, что скрывается в его названии: сообщает объявленный тип (***declared type***) имени.

>[!note] Следует запомнить
>- `decltype` почти всегда дает тип переменной или выражения без каких-либо изменений.
>- Для `lvalue`- выражений типа `T`, отличных от имени, `decltype` всегда дает тип `T&`.
>- C++14 поддерживает конструкцию `decltype(auto)`, которая, подобно `auto`, выводит тип из его инициализатора, но выполняет вывод типа с использованием правил `decltype`.