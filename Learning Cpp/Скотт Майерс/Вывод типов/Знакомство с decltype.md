`decltype` - создание странное. Для данного имени или выражения `decltype` сообщает вам тип этого имени или выражения. Обычно то, что сообщает `decltype`, - это именно то, что вы предсказываете. Однако иногда он дает результаты, которые заставляют вас чесать в затылке.

Начнем с типичных случаев, в которых нет никаких подводных камней. В отличие от того, что происходит в процессе вывода типов для [[Learning Cpp/Скотт Майерс/Вывод типов/Вывод типа шаблона.md|шаблонов]] и [[Learning Cpp/Скотт Майерс/Вывод типов/Вывод типа auto.md|auto]], `decltype` обычно попугайничает, возвращая точный тип имени или выражения, которое вы передаете ему:
```cpp
const int i = 0;         // decltype(i) - const int

bool f(const Widget& w); // decltype(w) - const Widget&
                         // decltype(f) - bool(const Widget&)
struct Point {
	int x, y;            // decltype(Point::x) - int
};                       // decltype(Point::y) - int

Widget w;                // decltype(w) - Widget

if (f(w)) ...            // decltype(f(w)) - bool

template<typename T>     // упрощенная версия std::vector
class vector {
public:
	...
	T& operator[](std::size_t index);
};

vector<int> v;           // decltype(v) - vector<int>
...
if (v[0] == 0) ...       // decltype(v[0]) - int&
```
Никаких сюрпризов.

Пожалуй, основное применение `decltype` в C++ - объявление шаблонов функций, в которых возвращаемый тип функции зависит от типов ее параметров.

Предположим, например, что мы хотим написать функцию, получающую контейнер, который поддерживает индексацию с помощью квадратных скобок с индексом, а затем аутентифицирует пользователя перед тем как вернуть результат операции индексации.
`operator[]` для контейнера объектов типа `T` обычно возвращает `T&`. Например, это так в случае `std::deque` и почти всегда - в случае `std::vector`. Однако для `std::vector<bool>` оператор `operator[]` не возвращает `bool&`. Вместо этого он возвращает новый объект. Причины такого поведения рассматриваются в другом [[Learning Cpp/Скотт Майерс/Объявление auto/Если auto выводит нежелательный тип, используйте явно типизированный инициализатор.md|разделе]], но главное здесь то, что возвращаемый оператором `operator[]` контейнера тип зависит от самого контейнера.

`decltype` упрощает выражение этой зависимости. Вот пример, показывающий применение `decltype` для вычисления возвращаемого типа. Этот шаблон требует уточнения, но пока что мы его отложим.
```cpp
template<typename Container, typename Index> // работает, но
auto authAndAccess(Container& c, Index i)    // требует
	-> decltype(c[i])                        // уточнения
{
	authenticateUser();
	return c[i];
}
```
Использование `auto` перед именем функции не имеет ничего общего с выводом типа. На самом деле оно указывает, что использован синтаксис C++11 - *завершающий возвращаемый тип* (trailing return type), т.е. что возвращаемый тип функции будет объявлен после списка параметров (после "->").
Завершающий возвращаемый тип обладает тем преимуществом, что в спецификации возвращаемого типа могут использоваться параметры функции. В `authAndAccess`, например, мы указываем возвращаемый тип с использованием `c` и `i`.
Если бы возвращаемый тип, как обычно, предшествовал имени функции, `c` и `i` были бы в нем недоступны, поскольку в этот момент они еще не были объявлены.

При таком объявлении `authAndAccess` возвращает тот тип, который возвращает `operator[]` при применении к переданному контейнеру, в точности как мы хотели.

С++11 разрешает вывод возвращаемых типов лямбда-выражений из одной инструкции, а С++14 расширяет эту возможность на все лямбда-выражения и все функции, включая состоящие из множества инструкций.
В случае `authAndAccess` это означает, что в С++14 мы можем опустить завершающий возвращаемый тип, оставляя только одно ведущее ключевое слово `auto`. При таком объявлении `auto` означает, что компиляторы будут выводить возвращаемый тип функции из ее реализации:
```cpp
template<typename Container, typename Index>  // C++14
auto authAndAccess(Container& c, Index i)     // Не совсем корректно
{
	authenticateUser();
	return c[i]; // Возвращаемый тип выводится из c[i]
}
```
В [[Learning Cpp/Скотт Майерс/Вывод типов/Вывод типа auto.md|разделе про вывод типа auto]] поясняется, что для функций с `auto`-спецификацией возвращаемого типа компиляторы применяют вывод типа шаблона. В данном случае это оказывается проблематичным. Как уже говорилось, `operator[]` для большинства контейнеров с объектами типа `T` возвращает `T&`, но в разделе [[Вывод типа шаблона]] поясняется, что в процессе вывода типа шаблона "ссылочность" инициализирующего выражения игнорируется. Рассмотрим, что это означает для следующего клиентского кода:
```cpp
std::deque<int> d;
...
authAndAccess(d, 5) = 10; // Аутентифицирует пользователя,
						  // возвращает d[5], затем приписывает ему
						  // значение 10. 
// Код не компилируется!
```
Здесь `d[5]` возвращает `int&`, но вывод возвращаемого типа `auto` для `authAndAccess` отбрасывает ссылку,  тем самым давая возвращаемый тип `int`. Этот `int`, будучи возвращаемым значением функции, является `rvalue`, так что приведенный выше код пытается присвоить этому `rvalue` типа `int` значение 10. Это запрещено в С++, так что данный код не компилируется.

Чтобы заставить `authAndAccess` работать так, как мы хотим, нам надо использовать для ее возвращаемого типа вывод типа `decltype`, т.е. указать, что `authAndAccess` должна возвращать в точности тот же тип, что и выражение `c[i]`. Это возможно сделать, начиная с С++14, с помощью `decltype(auto)`.
То, что поначалу может показаться противоречием (`decltype` и `auto`?), в действительности имеет смысл: `auto` указывает, что тип должен быть выведен, а `decltype` говорит о том, что в процессе вывода следует использовать правила `decltype`.
Итак, можно записать `authAndAccess` следующим образом:
```cpp
template<typename Container, typename Index> // С++14; работает,
decltype(auto)                               // но все еще
authAndAccess(Container& c, Index i)         // требует уточнения
{
	authenticateUser();
	return c[i];
}
```
Теперь `authAndAccess` действительно возвращает то же, что и `c[i]`. В частности, в распространенном случае, когда `c[i]` возвращает `T&`, `authAndAccess` также возвращает `T&`, и в том редком случае, когда `c[i]` возвращает объект, `authAndAccess` также возвращает объект.

Использование `decltype(auto)` не ограничивается возвращаемыми типами функций. Это также может быть удобно для объявления переменных, когда вы хотите применять правила вывода типа `decltype` к инициализирующему выражению:
```cpp
Widget w;
const Widget& cw = w;

auto myWidget1 = cw;            // Вывод типа auto:
                                // тип myWidget1 - Widget


decltype(auto) myWidget2 = cw;  // Вывод типа decltype:
                                // тип myWidget2 - const Widget&
```

Еще раз посмотрим на версию `authAndAccess` в С++14:
```cpp
template<typename Container, typename Index>
decltype(auto) authAndAccess(Container& c, Index i);
```
Контейнер передается как `lvalue`-ссылка на неконстантный объект, поскольку возвращаемая ссылка на элемент контейнера позволяет клиенту модифицировать этот контейнер.
Но это означает, что этой функции невозможно передавать контейнеры, являющиеся `rvalue`. `rvalue` невозможно связать с `lvalue`-ссылками (если только они не являются `lvalue`-ссылками на константные объекты, что в данном случае очевидным образом не выполняется).

Вообще, передача контейнера, являющегося `rvalue`, в `authAndAccess` является крайним случаем. Такой `ravlue`-контейнер, будучи временным объектом, обычно уничтожается в конце инструкции, содержащей вызов `authAndAccess`, а это означает, что ссылка на элемент в таком контейнере (то, что должна вернуть функция `authAndAccess`) окажется "висячей" в конце создавшей его инструкции.

Тем не менее передача временного объекта функции `authAndAccess` может иметь смысл. Например, клиент может просто хотеть сделать копию элемента во временном контейнере:
```cpp
std::deque<std::string> makeStringDeque(); // Фабричная функция

// Делаем копию пятого элемента deque, возврщаемого
// функцией makeStringDeque
auto s = authAndAccess(makeStringDeque(), 5);
```