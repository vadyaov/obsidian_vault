#done #opened 

Обычно, объекты, захватившие ресурсы в некоторой области видимости, освобождали их по выходу из этой области видимости.

Для управления объектами в свободной памяти стандартная библиотека в файле `<memory>` определяет два вида [интеллектуальных указателей](obsidian://open?vault=Obsidian%20Vault&file=Learning%20Cpp%2F%D0%A1%D1%82%D1%80%D0%B0%D1%83%D1%81%D1%82%D1%80%D1%83%D0%BF%2F%D0%9E%D0%B1%D0%B7%D0%BE%D1%80%20%D1%81%D1%82%D0%B0%D0%BD%D0%B4%D0%B0%D1%80%D1%82%D0%BD%D0%BE%D0%B9%20%D0%B1%D0%B8%D0%B1%D0%BB%D0%B8%D0%BE%D1%82%D0%B5%D0%BA%D0%B8%2F%D0%9F%D0%B0%D0%BC%D1%8F%D1%82%D1%8C%20%D0%B8%20%D1%80%D0%B5%D1%81%D1%83%D1%80%D1%81%D1%8B%2F%D0%A3%D0%BC%D0%BD%D1%8B%D0%B5%20%D1%83%D0%BA%D0%B0%D0%B7%D0%B0%D1%82%D0%B5%D0%BB%D0%B8):
1. `unique_ptr` для отражения концепции уникального владения. 
2. `shared_ptr` для отражения концепции разделяемого владения.

Самое важное применение этих указателей нацелено на предотвращение утечек памяти. Например:
```cpp
// Сравним X* и unique_ptr<X>
void f(int i, int j) {
	X* p = new X;
	unique_ptr<X> sp {new X};
	// ...
	if (i < 99) throw Z{};
	if (j < 77) return;

	p->do_smth();
	sp->do_smth();

	delete p;
}
```

Здесь мы забыли применить операцию `delete` к `p` в случает `i < 99 и j < 77`. в то же время `unique_ptr` гарантирует, что владеемый им объект будет надлежащим образом уничтожен, незавсимо от того, как происходит выход из функции.

Другое применение `unique_ptr` заключается в передаче объектов, размещаемых в свободной памяти, в функцию и их возврат из нее:
```cpp
unique_ptr<X> make_X(int i)
{
	// ... проверяем i, и т.д.

	return unique_ptr<X>{new X{i}};
}
```

> [!note]
> Интеллектуальный указатель `unique_ptr` является декскриптором для индивидуального объекта (или массива) аналогично тому, как `vector` служит дескриптором для последовательности объектов. Оба управляют временем жизни объектов и оба полагаются на семантику перемещения, чтобы выполнять возврат просто и эффективно.

Интеллектуальный указатель `shared_ptr` аналогичен `unique_ptr` за исключением того, что он скорее копирует, чем перемещает. Многочисленные `shared_ptr` на объект разделяют владение объектом, и объект уничтожается лишь тогда, когда уничтожается последний из этих `shared_ptr`.
```cpp
void f(shared_ptr<fstream>);
void g(shared_ptr<fstream>);

void user(const string& name, ios::base::openmode mode)
{
	shared_ptr<fstream> fp {new fstream(name, mode)};
	if (!fp) throw No_file{}; // проверка корректности открытия файла

	f(fp);
	g(fp);
	// ...
}
```

Теперь файл, открытый конструктором `fp`, будет закрываться последней функцией, которая (явно или неявно) уничтожает копию `fp`.

> [!note]
> `f()` и `g()` могут запустить задачу с отдельной копией `fp` или же иным способом хранить копию, которая переживет `user()`.
> Таким образом `shared_ptr` реализует некоторую форму "сборки мусора", опирающуюся на деструкторы в управлении ресурсами при работе с объектами в памяти.

> [!tip]
> Использование `shared_ptr` не является бесплатным и не является слишком дорогим методом, но делает время жизни объекта менее предсказуемым.
> Используйте `shared_ptr` исключительно в случаях, когда на самом деле требуется совместное владение объектами.

>[!question]- Когда следует использвать умные указатели (такие как `unique_ptr`) вместо применения ресурсных дескрипторов с их операциями, специально разработанными под ресурсы (`vector` / `thread`)?
>
>Как это не удивительно - тогда, когда нам нужна семантика указателей:
>- Когда выполняется совместный (разделяемый) доступ к объекту, нам нужны указатели (ссылки) на разделяемый объект, так что в этом случае `shared_ptr` является очевидным выбором.
>- Когда мы ссылаемся на полиморфный объект, нам требуются указатели (или ссылки), потому что мы не знаем точного типа объекта и даже его размера, так что `unique_ptr` становится очевидным выбором.
>- Разделяемые полиморфные объекты в типичном случае требуют `shared_ptr`.

В то же время, нет нужды в указателях при возврате коллекций объектов из функции; контейнер, являющийся ресурсным дескриптором, делает это просто и эффективно.