В типичном случае задача нуждается в данных, над которыми будет производиться работа.
```cpp
void f(vector<double>& v); // функция что то делает c v

struct F { // объект-функция: что-то сделать с v
	vector<double>& v;
	F(vector<double>& vv) : v{vv} {}
	void operator()(); // операция вызова
};

int main() {
	vector<double> some_vec {1, 2, 3, 4, 5, 6, 7, 8, 9};
	vector<double> vec2 {10, 11, 12, 13, 14, 15};

	thread t1 {f, some_vec};
	thread t2 {F{vec2}};

	t1.join();
	t2.join();
}
```
Очевидно, что `F{vec2}` сохраняет ссылку на аргумент (вектор) в `F`. F может после этого использовать этот вектор и надеяться, что никакая другая задача не имеет доступа к `vec2`, пока исполняется `F`. Передача `vec2` по значению устраняет этот риск.

Инициализация значением `{f, some_vec}` использует шаблонный конструктор класса `thread` с переменным числом параметров. Компилятор проверяет, что первый параметр может быть вызван с аргументами, указанными с помощью следующих параметров, и строит нужный функциональный объект, который и передается потоку.

Таким образом, если `F::operator()()` и `f()` реализуют один и тот же алгоритм, выполнения двух задач будет приблизительно эквивалентным: в обоих случаях конструируется фукциональный объект для исполнения в потоке.