В примере из [[Передача аргументов]] аргументы передавались с помощью неконстантной ссылки, то есть ожидается, что задача будет модифицировать значение данных, адресуемых ссылкой.

Это несколько коварный, но не такой уж и редкий способ возврата результатов. Менее туманная техника заключается в том, чтобы передавать данные по константной ссылке, а также отдельным аргументом передавать место, в которое будет положен результат:
```cpp
void f(const vector<double>& v, double* res); // результат в *res

class F {
public:
	F(const vector<double>& vv, double* p) : v{vv}, res{p} {}
	void operator()(); // помещаем результат в *res
private:
	const vector<double>& v; // источник ввода
	double* res; // цель вывода
};

int main() {
	vector<double> some_vec;
	vector<double> vec2;
	// ...

	double res1;
	double res2;

	thread t1 {f, some_vec, &res1};
	thread t2 {F{vec2, &res2}};

	t1.join();
	t2.join();

	cout << res1 << ' ' << res2 << "\n";
}
```

Возврат через параметры не считается особо элегантным. Поэтому вернемся к этому вопросу в [[future и promise]].