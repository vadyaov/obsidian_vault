Иногда поток должен ждать наступления какого-либо внешнего события, например завершения работы другого потока или же истечения некторого интервала времени. Рассмотрим следующее:
```cpp
using namespace std::chrono;

auto t0 = high_resolution_clock::now();
this_thread::sleep_for(milliseconds{20});
auto t1 = hight_resolution_clock::now();

cout << duration_cast<nanoseconds>(t1 - t0).count() << " nanoseconds passed\n";
```
Тут не пришлось запускать поток; по умолчанию, `this_thread` ссылается на один и только на один поток.

Базовая поддержка коммуникаций на основе внешних событий обеспечивается посредством `condition_variable` и находится в файле `<conditon_variable>`.
Тип `condition_variable` является механизмом, помогающим одному потоку ждать другого. В частности, он позволяет потоку ожидать выполнения некоторого условия (события), ялвяющегося следствием результата работы других потоков.

Рассмотрим классический пример двух потоков, взаимодействующих посредством передачи сообщений через очередь (`queue`).
```cpp
class Message {   // объект коммуникации
	// ...
};

queue<Message> mqueue;    // очередь сообщений
condition_variable mcond; // ожидание событий коммуникации
mutex mmutex;             // механизм блокировки
```
Типы `queue`, `condition_variable` и `mutex` обеспечиваются стандартной библиотекой.
Потребитель (`consumer`) читает и обрабатывает сообщения (объекты типа `Message`):
```cpp
void consumer()
{
	while (true)
	{
		unque_lock<mutex> lck{mmutex}; // захватываем mmutex
		/* ничего не делаем */
		while (mcond.wait(lck))        // освобождаем lck и ждем

		// снова захватываем lck по пробуждению
		auto m = mqueue.front();
		mqueue.pop();
		lck.unlock();                  // освобождаем lck
		// ... обрабатываем m ...
	}
}
```
Здесь явным образом вводится защита операций с очередью и условной переменной с помощью `unique_lock` над `mutex`.
В цикле ожидания `condition_variable` блокировка находится в освобожденном состоянии до тех пор, пока `condition_variable` не просигнализирует о событии (в очередь поступит сообщение), после чего блокировка снова захватывается.

Соответсвующий производитель (`producer`) выглядит следующим образом:
```cpp
void producer()
{
	while (true)
	{
		Message m;
		// ... заполняем сообщение ...
		unique_lock<mutex> lck {mmutex}; // защищаем операции
		mqueue.push(m);
		mcond.notify_one(); // уведомляем
	} // освобождается блокировка (по области видимости)
}
```

>[!info]
>Применение условные переменных (`conditional_variable`) поддерживает много разных форм элегантного и эффективного совиестного доступа к данным (sharing), но эти приемы не совсем очевидны и не так уж просты.

[[Условные переменные]]