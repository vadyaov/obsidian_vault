Иногда задачам нужен совместный доступ к данным (разделяемые данные). В этом случае доступ к данным должен быть синхронизирован таким образом, чтобы лишь одна задача обращалась к данным в опреленный момент времени.

>[!tip]
>Нет ничего плохого в том, что многие задачи одновременно читают неизменяемые данные.

>[!question]
>Но как вообще можно гарантировать, что лишь одна задача в конкретный момент имеет доступ к заданному набору объектов?

Фундаментальным решение проблемы служит `mutex`. Поток (`thread`) захватывает *`mutex`*, используя операцию `lock()`:

```cpp
mutex m;
int sh;

void f()
{
	unique_lock<mutex> lck {m}; // захват мьютекса
	sh += 7; // манипултруем разделяемыми данными
} // неявно освобождаем мьютекс

```
Конструктор `unique_lock` захватывает семафор (mutex) посредством вызова `m.lock()`. Если другой поток уже захватил семафор, поток ждет (блокируется) до тех пор, пока у другого потока не отпадет нужда в доступе. В случае, когда отпадает нужда в доступе к разделяемым данным, `unique_lock` освобождает семафор посредством вызова `m.unlock()`.

Соответствие между разделяемыми данными и семафорами очевидное: программист должен знать, какой семафор предназначен для каких данных. Это, конечно, может порождать ошибки, и мы пытаемся прояснять соответствие через различные средства языка:

```cpp
class Record {
public:
	mutex rm;
	// ...
};
```
Не надо быть гением, чтобы угадать, что для объекта `rec` типа `Record`, `rec.rm` является семафором, который вы должны захватывать перед тем, как обратиться к иным данным `rec` (*посредством комментария или более подходящего имени это можно сделать более понятным для читателя кода*).

Иногда нужен одновременный доступ к нескольким ресурсам с целью выполнения определенного действия. Это может приводить к клинчу.
>[!example]
>Поток `thread1` захватил семафор `mutex1`, а затем пытается захватить еще и семафор `mutex2`, в то время как поток `thread2` уже захватил семафор `mutex2` и пытается захватить `mutex1`.
>В результате ни одна из задач не может продвинуться в своей работе.

Стандартная библиотека предлагает тут в помощь операцию, позволяющую выполнить несколько одновременных блокировок:
```cpp
void f() {
	// ...

    // defer_lock: не пытается захватить мьтекс
    unique_lock<mutex> lck1 {m1, defer_lock};
	unique_lock<mutex> lck2 {m2, defer_lock};
	unique_lock<mutex> lck3 {m3, defer_lock};
	// ...
	lock(lck1, lck2, lck3); // захватываем три блокировки
	// .. манипулируем разделяемыми данными
} // неявно освобождаем все мьютексы
```
Здесь `lock()` сработает только тогда, когда будут захвачены все его аргументы и никогда не приведет к блокировке, пока он удерживает семафор. Деструкторы индивидуальных объектов типа `unique_lock` гарантируют, что семафоры будут освобождены, когда поток выйдет из области видимости.

Взаимодействие посредством разделяемых данных является весьма низкоуровневой задачей. В частности, программисту нужно каким-то образом суметь узнать, какие работы выполнены и какие не выполнены различными задачами. В этом отношении применение разделяемых данных является худшей альтернативой концепциям вызова и возврата.

С другой стороны, некоторые люди считают, что разделяемые данные обеспечивают большую эффективность, чем копирование аргументов и выполнение возврата. Это на самом деле так в ситуациях, когда приходится иметь дело с огромными объемами данных, но сами по себе операции блокировки и снятия блокировок являются относительно дорогими операциями.

А с другой стороны, современные машины очень даже хороши в копировании данных, таких как элементы типа `vector`.

>[!success]
>В итоге, не следует кидаться применять разделяемые данные в цедях эффективности без тщательных раздумий и без измерений.
