#done #opened

Одним из наиболее полезных видов шаблонов является *функциональный объект*, называемый также *функтором*, который используется для определения объектов, обратиться к которым можно так, как выполняется вызов функции.

```cpp
 template<typename T>
 class Less_than {
 	const T val;
 public:
 	Less_than(const T& v) : val(v) {}
 	bool operator()(const T& x) const {return x < val;} // операция вызова
 };
 ```
 
 Метод `operator()` реализует вызов функции.
 ```cpp
 Less_than<int> lti {42}; // lti(i) == (i < 42)
 Less_than<string> lts {"backus"}; // lts(s) == (s < "backus")
 ```

Подобного рода функциональные объекты широко используются в качестве аргументов алгоритмов. Например, мы можем подсчитать количество случаев, для которых преликат (условие) истинен (возвращает true):
```cpp
template<typename C, typename P>
int count(const C& c, P pred) {
	int cnt = 0;
	for (const auto& x : c) {
		if (pred(x)) ++cnt;
	}
	return cnt;
}
```
```cpp
int main() {
	std::vector<int> vec = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
	std::list<std::string> lst = {"abba", "baba", "aaaa", "aaab", "abaa"};

	std::cout << count(vec, Less_than{7}) << std::endl;
	std::cout << count(lst, Less_than{"abba"}) << std::endl;
	
	return 0;
}

```
Здесь `Less_than{x}` конструирует объект, который операция вызова сравнивает с `x`. 
Особая красота функциональных объектов состоит в том, что они всегда носят с собой значение, с которым производится сравнение. Нам не нужно писать все новые функции для новых типов, и нам не нужно связываться с "ужасными" глобальными переменными, чтобы те содержали сравниваемые значения.

Кроме того, для простых функциональных объектов, вроде `Less_than`, очень просто выполняется встраивание (*inlining*), и в итоге операция вызова для `Less_than` намного эффективнее непрямого вызова функции.
>[!info]
>Функциональные объекты, которые используются для уточнения смысла ключевых операция обобщенного алгоритма (как `Less_than` для `count`), часто называют объектами политики (*policy objects*).

Мы определяем `Less_than` отдельно от его использования. Это бывает неудобно. Как следствие, имеется специальна нотация для неявной генерации функциональных объектов:
```cpp
std::cout << count(vec, [&](int a) {return a < 7;}) << std::endl;
std::cout << count(lst, [&](const string& s) {return s < "abba";}) << std::endl;
```
> [!info]
> Обозначение `[&](int a) {return a < x;}` называется [[Lambda expression]] (*лямбда выражение*) или просто *лямбда*. 
> Оно генерирует функциональный объект, в точноси равный `Less_than<int>{x}`.
> 
> `[&]` - это список захвата (*capture list*), специфицирующий локальные имена (такие как `x`), передаваемые по ссылке;
>- Если требуется захватить по ссылке только `x` `[&x]`
>- Если нужно захватить `x` по значению `[=x]`
>- Пустой список захвата  - `[]`
>- Захват всех локальных переменных для передачи по ссылке - `[&]`
>- Захват всех локальных переменных для передачи по значению - `[=]`
