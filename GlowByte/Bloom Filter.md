**Постановка задачи**

В текущем формате колоночные статистики и словари могут использоваться для предикатного фильтра (predicate pushdown). Статистики включают минимальные и максимальные значения, которые помогают отсеивать значения, не попадающие в заданный диапазон. Словари содержат более точные данные, и чтение может исключить значения, которые находятся между минимальным и максимальным значением, но отсутствуют в словаре. Однако, когда существует слишком много уникальных значений, записывающие процессы иногда решают не добавлять словари, чтобы избежать лишних затрат на память. Это оставляет колонки с высокой кардинальностью и широко разнесенными min и max значениями без поддержки предикатного фильтра.

**Фильтр Блума** — это компактная структура данных, которая позволяет приблизительно представлять множество. Она может отвечать на запросы о принадлежности элементов, возвращая либо "точно нет", либо "возможно да", при этом вероятность ложных срабатываний (false positives) настраивается при инициализации фильтра. Важно, что фильтры Блума не дают ложных отрицаний (false negatives).

Так как фильтры Блума занимают меньше места по сравнению со словарями, их можно использовать для предикатного фильтра даже в столбцах с высокой кардинальностью и при ограниченных ресурсах памяти.

**Цель**
- Обеспечить предикатный фильтр для столбцов с высокой кардинальностью, используя меньше памяти, чем при использовании словарей.
- Избежать дополнительных затрат на ввод-вывод при выполнении запросов для столбцов, к которым не прикреплены фильтры Блума, или при выполнении неселективных запросов.

**Технический подход**

В этом разделе рассматриваются разделенные блочные фильтры Блума, которые являются первым (и, на момент написания, единственным) типом фильтров Блума, поддерживаемым в Parquet.

Сначала опишем «блок» — основной компонент, из которого состоят разделенные блочные фильтры Блума.

Каждый блок состоит из 256 бит, разделенных на восемь последовательных «слов», каждое из которых содержит 32 бита. Каждое слово можно рассматривать как массив битов; каждый бит может быть либо «установлен» (set), либо «не установлен» (not set).

При инициализации блок является «пустым», что означает, что ни один из битов в восьми словах блока не установлен. Помимо инициализации, блок поддерживает две другие операции: `block_insert` и `block_check`. Обе операции принимают одно беззнаковое 32-битное целое число в качестве входного параметра; `block_insert` не возвращает значения, но изменяет блок, в то время как `block_check` возвращает булево значение. Семантика `block_check` заключается в том, что она должна вернуть `true`, если `block_insert` ранее был вызван с тем же аргументом, и в противном случае возвращает `false` с высокой вероятностью. Для получения дополнительных сведений о вероятности см. ниже.

Операции `block_insert` и `block_check` зависят от некоторых вспомогательных объектов. Во-первых, имеется последовательность из восьми нечетных беззнаковых 32-битных целых чисел, называемых «солью» (salt). Во-вторых, существует метод `mask`, который принимает одно беззнаковое 32-битное целое число и возвращает блок, в котором в каждом слове установлен ровно один бит.
```cpp
unsigned int32 salt[8] = {0x47b6137bU, 0x44974d91U, 0x8824ad5bU,
                          0xa2b7289dU, 0x705495c7U, 0x2df1424bU,
                          0x9efc4947U, 0x5c6bfb31U}

block mask(unsigned int32 x) {
  block result
  for i in [0..7] {
    unsigned int32 y = x * salt[i]
    result.getWord(i).setBit(y >> 27)
  }
  return result
}
```
Поскольку в блоке восемь слов и в соли также восемь целых чисел, между ними существует соответствие. Чтобы установить бит в n-м слове блока, `mask` сначала умножает свой аргумент на n-е целое число из соли, сохраняя только младшие 32 бита 64-битного произведения, а затем делит это 32-битное беззнаковое целое число на \(2^{27}\), что обозначается оператором сдвига вправо ">>" в языке C. Полученное число находится в диапазоне от 0 до 31 включительно и определяет бит, который будет установлен в слове блока.

На основе операции `mask` определяются функции `block_insert` и `block_check`:
- `block_insert` устанавливает каждый бит в блоке, который также установлен в результате выполнения `mask`.
- `block_check` возвращает `true`, если каждый бит, установленный в результате выполнения `mask`, также установлен в блоке.
```cpp
void block_insert(block b, unsigned int32 x) {
  block masked = mask(x)
  for i in [0..7] {
    for j in [0..31] {
      if (masked.getWord(i).isSet(j)) {
        b.getWord(i).setBit(j)
      }
    }
  }
}
```
```cpp
boolean block_check(block b, unsigned int32 x) {
  block masked = mask(x)
  for i in [0..7] {
    for j in [0..31] {
      if (masked.getWord(i).isSet(j)) {
        if (not b.getWord(i).setBit(j)) {
          return false
        }
      }
    }
  }
  return true
}
```
Читатель заметит, что блок, как он определён здесь, представляет собой особый вид фильтра Блума, а именно «разделённый» фильтр Блума, описанный в разделе 2.1 статьи *Network Applications of Bloom Filters: A Survey*. Использование умножения на нечетную константу с последующим сдвигом вправо — это метод хеширования целых чисел, описанный в разделе 2.2 работы *Dietzfelbinger et al., A reliable randomized algorithm for the closest-pair problem*.

Этим завершается определение блока и операций над ним.

Теперь, когда блок определен, мы можем описать разделенные блочные фильтры Блума в Parquet. Разделенный блочный фильтр Блума (далее SBBF) состоит из *z* блоков, где *z* больше или равно единице и меньше \(2^{31}\). При инициализации каждый блок в SBBF инициализируется, что означает, что каждый бит в каждом слове каждого блока в SBBF не установлен.

Кроме инициализации, SBBF поддерживает операции `filter_insert` и `filter_check`. Обе операции принимают 64-битное беззнаковое целое число в качестве аргумента; `filter_check` возвращает булево значение, а `filter_insert` не возвращает значения, но модифицирует SBBF.

Операция `filter_insert` сначала использует старшие 32 бита своего аргумента для выбора блока, с которым будет работать. Обозначим аргумент как "h" и напомним, что "z" — это количество блоков. Затем выбирается номер блока *i* от 0 до *z - 1* включительно, следующим образом:
```cpp
unsigned int64 h_top_bits = h >> 32;
unsigned int64 z_as_64_bit = z;
unsigned int32 i = (h_top_bits * z_as_64_bit) >> 32;
```
Первая строка извлекает старшие 32 бита из *h* и присваивает их 64-битному беззнаковому целому числу. Вторая строка проще: она просто задает 64-битное беззнаковое значение, равное 32-битному беззнаковому значению *z*. Цель того, что *h_top_bits* и *z_as_64_bit* — это 64-битные значения, состоит в том, чтобы их произведение было также 64-битным. Это произведение вычисляется в третьей строке, после чего старшие 32 бита извлекаются в значение *i*, которое является индексом блока, с которым будет проводиться операция.

После этого процесса выбора *i* операция `filter_insert` использует младшие 32 бита *h* в качестве аргумента для вызова `block_insert` для выбранного блока *i*.

Метод преобразования старших 32 бит в целое число от 0 до *z - 1* включительно позволяет избежать использования операции по модулю, которая часто является медленной. Этот трюк описан в исследовательском отчете IBM 2006 года Кеннета А. Росса, *Efficient Hash Probes on Modern Processors*.

Операция `filter_check` использует тот же метод, что и `filter_insert`, для выбора блока, а затем использует младшие 32 бита своего аргумента в качестве аргумента для вызова `block_check` для этого блока, возвращая результат.

В приведенном ниже псевдокоде оператор модуля представлен оператором «%» языка C. Оператор «>>» обозначает преобразование беззнакового 64-битного целого числа в беззнаковое 32-битное, содержащее только старшие 32 бита, а оператор приведения типа «(unsigned int32)» используется для преобразования беззнакового 64-битного целого числа в беззнаковое 32-битное целое, содержащее только младшие 32 бита.
```cpp
void filter_insert(SBBF filter, unsigned int64 x) {
  unsigned int64 i = ((x >> 32) * filter.numberOfBlocks()) >> 32;
  block b = filter.getBlock(i);
  block_insert(b, (unsigned int32)x)
}
```
```cpp
boolean filter_check(SBBF filter, unsigned int64 x) {
  unsigned int64 i = ((x >> 32) * filter.numberOfBlocks()) >> 32;
  block b = filter.getBlock(i);
  return block_check(b, (unsigned int32)x)
}
```

**Размер SBBF**

Операция проверки в SBBF может возвращать `true` для значения, которое никогда не было добавлено в SBBF. Такие случаи называются «ложноположительными». Вероятность ложноположительного результата — это вероятность того, что хеш-значение, которое никогда не было добавлено в SBBF, вызовет возврат `true` в проверке (ложноположительный результат). Простой замкнутой формулы для расчета этой вероятности не существует, но вот пример:

Фильтр, который использует 1024 блока и в который добавлено 26,214 хеш-значений, будет иметь вероятность ложноположительного результата около 1.26%. Каждый из этих 1024 блоков занимает 256 бит пространства, что составляет 262,144 бита общего объема. Это означает, что соотношение количества битов к числу хеш-значений — 10 к 1. Добавление большего количества хеш-значений увеличивает знаменатель и снижает это соотношение, что увеличивает вероятность ложноположительного результата. Например, добавление вдвое большего количества хеш-значений (52,428) снижает соотношение битов на каждое добавленное хеш-значение до 5 к 1 и увеличивает вероятность ложноположительного результата до 18%. Добавление вдвое меньшего количества хеш-значений (13,107) увеличивает соотношение битов на каждое добавленное хеш-значение до 20 к 1 и снижает вероятность ложноположительного результата до 0.04%.

Примеры значений соотношений для достижения определённых уровней вероятности ложноположительного результата:

| Биты на добавленное значение | Вероятность ложноположительного результата |
| :--------------------------: | :----------------------------------------: |
|             6.0              |                    10 %                    |
|             10.5             |                    1 %                     |
|             16.9             |                   0.1 %                    |
|             26.4             |                   0.01 %                   |
|              41              |                  0.001 %                   |
